// TODO: add controllder input check
global function Pilot_WallClimb_Init

const float GRUNT_WALLCLIMB_ANGLE_LIMIT = 45.0 // other than this will consider as not facing a wall
const float WALLCLIMB_GRACE_PERIOD_TIME = 0.3 // if you press left or right within this time you won't be kick off wall

struct
{
	table<entity, float> playerWallRunBeinTime
} file

void function Pilot_WallClimb_Init()
{
    // I can't handle "PilotStartWallClimb" now
    RegisterSignal( "PilotStartWallClimb" )
    RegisterSignal( "PilotStopWallClimb" )

	RegisterSignal( "PilotWallClimbThink" )
	// ttf2 don't have other ways to modify classmods other than change class, so this is enough
	AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
}


//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnClientConnected( entity player )
{
	file.playerWallRunBeinTime[player] <- 0.0
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.BEGIN_WALLRUN, UpdatePlayerWallRunBeginTime )
}

void function OnPlayerClassChanged( entity player )
{
    thread PilotWallClimbThink( player )
}

void function UpdatePlayerWallRunBeginTime( entity player )
{
	file.playerWallRunBeinTime[player] = Time()
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// UTILITY FUNCTIONS /////
/////////////////////////////

void function PilotWallClimbThink( entity player )
{
	// only run for living players( dead players will also change class to "spectator", prevent it )
	if ( !IsAlive( player ) )
		return

	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.Signal( "PilotWallClimbThink" )
	player.EndSignal( "PilotWallClimbThink" )

	// check wallclimb mod, ttf2 don't have other ways to modify classmods than change class so this is enough
	bool hasWallClimb = false
	float angleLimit
	array<string> classMods = player.GetPlayerSettingsMods()
	// grunt mode climber
	if ( classMods.contains( "only_wallclimb" ) ||
		 classMods.contains( "doublejump_wallclimb" ) ||
		 classMods.contains( "amped_wallclimb" )
	) 
	{
		hasWallClimb = true
		angleLimit = GRUNT_WALLCLIMB_ANGLE_LIMIT
	}

	if ( !hasWallClimb )
		return

	bool isClimbingWall
	vector wallAngles
	while( true )
	{
		if ( isClimbingWall && !player.IsWallRunning() ) // considering player has left the wall?
		{
			player.Signal( "PilotStopWallClimb" )
			isClimbingWall = false
		}

		WaitFrame() // always wait first

		if ( player.IsWallHanging() ) // allow player to do wallhang
			continue

		// main mechanic: kick player off wall if they're not facing it, only wall climbing!
		if ( player.IsWallRunning() )
		{
			if ( !isClimbingWall ) // new wall climbing
				wallAngles = TracePlayerWallAngles( player )

			// comparing yaw is enough
			float wallAnglesYaw = wallAngles.y

			// get player's viewing angle, comparing yaw is enough
			float eyeAnglesYaw = VectorToAngles( player.GetViewVector() ).y

			float angDiffer = fabs( fabs( wallAnglesYaw - eyeAnglesYaw ) - 180 ) // formatting the differ
	
			// try to move on the wall( can't handle controller for now )
			if ( file.playerWallRunBeinTime[player] + WALLCLIMB_GRACE_PERIOD_TIME < Time() ) // has climbed long enough
			{
				if ( player.IsInputCommandHeld( IN_MOVELEFT ) || player.IsInputCommandHeld( IN_MOVERIGHT ) )
				{
					thread KickPlayerOffWall( player ) // knock player off
					continue
				}
			}

			if ( angDiffer > angleLimit ) // the angle diffrence is bigger than limit?
				thread KickPlayerOffWall( player )

			if ( !isClimbingWall )
			{
				player.Signal( "PilotStartWallClimb" )
				isClimbingWall = true // mark as start climbing
			}
		}
	}
}

vector function TracePlayerWallAngles( entity player )
{
	vector startPos = player.EyePosition()
	int attachID = player.LookupAttachment( "CHESTFOCUS" )
	if ( attachID > 0 )
		startPos = player.GetAttachmentOrigin( attachID )

	// comparing yaw is enough
	vector viewVec = player.GetViewVector()
	viewVec = AnglesToForward( < 0, VectorToAngles( viewVec ).y, 0 > ) * 50
	vector endPos = startPos + viewVec // get player's viewing wall

	TraceResults traceResult = TraceLine( 
											startPos, 
											endPos,
											player,
											(TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), 
											TRACE_COLLISION_GROUP_NONE 
										)

	// get the wall's normal
	vector normal = traceResult.surfaceNormal
	// get the wall's angle
	vector wallAngles = VectorToAngles( normal )

	return wallAngles
}

void function KickPlayerOffWall( entity player )
{
	player.ForceCrouch() // best way to do it
	WaitFrame() // wait is needed if you want to make them able to stand again
	player.UnforceCrouch() // restore stand
	player.ForceStand() // make player stand up for fight, no need to manually cancel crouch
	WaitFrame()
	player.UnforceStand() // restore crouch
}

/////////////////////////////////
///// UTILITY FUNCTIONS END /////
/////////////////////////////////
