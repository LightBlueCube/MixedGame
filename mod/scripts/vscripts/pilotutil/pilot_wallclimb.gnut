global function Pilot_WallClimb_Init

const float GRUNT_WALLCLIMB_ANGLE_LIMIT = 45.0 // other than this will consider as not facing a wall
const float RAVENANT_WALLCLIMB_ANGLE_LIMIT = 30.0


void function Pilot_WallClimb_Init()
{
    // I can't handle "PilotStartWallClimb" now
    RegisterSignal( "PilotStartWallClimb" )
    RegisterSignal( "PilotStopWallClimb" )

	RegisterSignal( "PilotWallClimbThink" )
	// ttf2 don't have other ways to modify classmods than change class, so this is enough
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
}


//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnPlayerClassChanged( entity player )
{
    thread PilotWallClimbThink( player )
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// UTILITY FUNCTIONS /////
/////////////////////////////

void function PilotWallClimbThink( entity player )
{
	// only run for living players( dead players will also change class to "spectator", prevent it )
	if ( !IsAlive( player ) )
		return

	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.Signal( "PilotWallClimbThink" )
	player.EndSignal( "PilotWallClimbThink" )

	// check wallclimb mod, ttf2 don't have other ways to modify classmods than change class so this is enough
	bool hasWallClimb = false
	float angleLimit
	array<string> classMods = player.GetPlayerSettingsMods()
	// grunt mode climber
	if ( classMods.contains( "only_wallclimb" ) ) 
	{
		hasWallClimb = true
		angleLimit = GRUNT_WALLCLIMB_ANGLE_LIMIT
	}
	// ravenant climber
	if ( classMods.contains( "wallclimber" ) )
	{
		hasWallClimb = true
		angleLimit = RAVENANT_WALLCLIMB_ANGLE_LIMIT
	}

	if ( !hasWallClimb )
		return

	bool isClimbingWall
	vector wallAngles
	while( true )
	{
		if ( isClimbingWall && !player.IsWallRunning() ) // considering player has left the wall?
		{
			player.Signal( "PilotStopWallClimb" )
			isClimbingWall = false
		}

		WaitFrame() // always wait first

		// main mechanic: kick player off wall if they're not facing it, only wall climbing!
		if ( player.IsWallRunning() )
		{
			if ( !isClimbingWall ) // new wall climbing
				wallAngles = TracePlayerWallAngles( player )

			// comparing yaw is enough
			float wallAnglesYaw = wallAngles.y

			// get player's viewing angle, comparing yaw is enough
			float eyeAnglesYaw = VectorToAngles( player.GetViewVector() ).y

			float angDiffer = fabs( fabs( wallAnglesYaw - eyeAnglesYaw ) - 180 ) // formatting the differ
	
			// try to move on the wall( can't handle controller for now )
			if ( player.IsInputCommandHeld( IN_MOVELEFT ) || player.IsInputCommandHeld( IN_MOVERIGHT ) )
			{
				thread KickPlayerOffWall( player ) // knock player off
				continue
			}

			if ( angDiffer > angleLimit ) // the angle diffrence is bigger than limit?
				thread KickPlayerOffWall( player )

			if ( !isClimbingWall )
			{
				player.Signal( "PilotStartWallClimb" )
				isClimbingWall = true // mark as start climbing
			}
		}
	}
}

vector function TracePlayerWallAngles( entity player )
{
	vector startPos = player.EyePosition()
	int attachID = player.LookupAttachment( "CHESTFOCUS" )
	if ( attachID > 0 )
		startPos = player.GetAttachmentOrigin( attachID )

	// comparing yaw is enough
	vector viewVec = player.GetViewVector()
	viewVec = AnglesToForward( < 0, VectorToAngles( viewVec ).y, 0 > ) * 50
	vector endPos = startPos + viewVec // get player's viewing wall

	TraceResults traceResult = TraceLine( 
											startPos, 
											endPos,
											player,
											(TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), 
											TRACE_COLLISION_GROUP_NONE 
										)

	// get the wall's normal
	vector normal = traceResult.surfaceNormal
	// get the wall's angle
	vector wallAngles = VectorToAngles( normal )

	return wallAngles
}

void function KickPlayerOffWall( entity player )
{
	player.ForceCrouch() // best way to do it
	WaitFrame() // wait is needed if you want to make them able to stand again
	player.UnforceCrouch() // restore stand
	player.ForceStand() // make player stand up for fight, no need to manually cancel crouch
	WaitFrame()
	player.UnforceStand() // restore crouch
}

/////////////////////////////////
///// UTILITY FUNCTIONS END /////
/////////////////////////////////
