untyped

global function ExtraAISpawner_Init

global function ExtraSpawner_SpawnTitanBT

global function ExtraSpawner_SpawnDropShip
global function ExtraSpawner_SpawnDropPod

global function ExtraSpawner_SpawnNPCInDropPod
global function ExtraSpawner_SpawnSpecialistGruntDropPod
global function ExtraSpawner_SpawnTitanRandom
global function ExtraSpawner_SpawnGunShip

global function ExtraSpawner_SpawnPilotElite
global function ExtraSpawner_SpawnPilotCanEmbark
global function ExtraSpawner_SpawnTitanWithPilot
// set up funcs
global function ExtraSpawner_SetUpNPCWeapons 
global function ExtraSpawner_SetUpNPCPilot
// these settings should be done in prematch, don't do it right after levelLoad
global function ExtraSpawner_SetNPCWeapons
global function ExtraSpawner_SetNPCAntiTitanWeapons

// boss titans
global function ExtraSpawner_SpawnBTWithCooper
global function ExtraSpawner_SpawnRoninWithAsh
global function ExtraSpawner_SpawnLegionWithBlisk
global function ExtraSpawner_SpawnMonarchWithSarah

global function ExtraSpawner_SpawnCarePackageToGetWeapons
// these settings should be done in prematch, don't do it right after levelLoad
global function ExtraSpawner_SetCarePackageWeapons
global function ExtraSpawner_SetCarePackageWeaponMods
global function ExtraSpawner_SetCarePackageWeaponModsMultiple

global function ExtraSpawner_SpawnReaperCanLaunchTicks

// these are no need to change
const asset CAREPACKAGE_MODEL = $"models/vehicle/escape_pod/escape_pod.mdl"

// basically medium animation pilots!
const array<asset> NPC_PILOT_ALLOWED_MODELS = 
[ 
	// note that only grunt models have proper animation for a npc
	$"models/humans/pilots/pilot_medium_stalker_m.mdl", 
	$"models/humans/pilots/pilot_medium_stalker_f.mdl", 
	$"models/humans/pilots/pilot_medium_geist_m.mdl", 
	$"models/humans/pilots/pilot_medium_geist_f.mdl", 
	$"models/humans/pilots/pilot_medium_reaper_m.mdl", 
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/sp_medium_geist_f.mdl", 
	$"models/humans/pilots/sp_medium_reaper_m.mdl", 
	$"models/humans/pilots/sp_medium_stalker_m.mdl" 
	/* // now leaving only mp pilot models, for others maybe spawn with their unique titans( like jack in bt, ash in ronin )
	$"models/humans/grunts/mlt_grunt_lmg.mdl", 
	$"models/humans/grunts/imc_grunt_lmg.mdl", 
	$"models/humans/grunts/imc_grunt_shield_captain.mdl", 
	$"models/Humans/heroes/imc_hero_ash.mdl", 
	$"models/Humans/heroes/imc_hero_blisk.mdl", 
	$"models/humans/heroes/mlt_hero_jack.mdl", 
	$"models/humans/heroes/mlt_hero_sarah.mdl", 
	*/
]

struct
{
	// npc weapons, should we add a struct to set up mods for them?
	table< string, array<string> > npcMainWeaponsTable
	table< string, array<string> > npcAntiTitanWeaponsTable

	// care package
	array<entity> usedplayer = []
	array<string> carePackageWeapons
	// now allowing every weapon to have a custom mod
	table< string, array<string> > carePackageWeaponMods
} file

void function ExtraAISpawner_Init()
{
	// intilize
	InitCarePackageDefaultSettings()
	InitDefaultNPCWeapons()
	// prowler
	ProwlerPrecache()
	// care package
	RegisterSignal( "PlayerUsedCarePackage" ) // for some grunt mode classes regen their ability?
	PrecacheModel( CAREPACKAGE_MODEL )
	// specialist grunts
	PrecacheModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )

	// this should be in _ai_pilots.gnut
	//RegisterSignal( "ForceStartMove" ) // the signal as been deleted
	
	if( GetMapName() != "mp_lobby" ) // prevent unable to enter lobby
	{
		AddCallback_OnNpcPilotBecomesTitan( OnNpcPilotBecomesTitan )
		AddCallback_OnNpcTitanBecomesPilot( OnNpcTitanBecomesPilot )
	}

	// if npc titan has a pilot inside, reset it's melee damageSourceId
	AddDamageCallbackSourceID( eDamageSourceId.auto_titan_melee, ApplyNormalMeleeIdToNPCTitan )

	// for debugging
	//AddClientCommandCallback( "pilotandtitan", CC_SpawnPilotAndTitan )
	//AddClientCommandCallback( "tickreaper", CC_SpawnReaperCanLaunchTicks )
	//AddClientCommandCallback( "gunship", CC_SpawnGunShip )
	//AddClientCommandCallback( "assassinpilot", CC_SpawnAssassinPilot )
	//AddClientCommandCallback( "specialistgrunt", CC_SpawnSpecialistGrunt )
	//AddClientCommandCallback( "pilot", CC_SpawnPilotElite )

	// npc pilot score event, better be added by gamemodes
	//AddDeathCallback( "npc_pilot_elite", KilledNPCPilotScoreEvent )
}

void function ProwlerPrecache()
{
	// don't precache corpses again, or game's existing model will become errors!
    PrecacheModel($"models/creatures/prowler/r2_prowler.mdl")
}

// this is default settings, modders can change later
void function InitCarePackageDefaultSettings()
{
	// carepackage weapons
	// new grunt mode: only contains launchers
	file.carePackageWeapons =
	[
		"mp_weapon_epg", 
		"mp_weapon_softball", 
		"mp_weapon_pulse_lmg", 
		"mp_weapon_smr" 
	]

	// anti-titan
	file.carePackageWeaponMods["mp_weapon_arc_launcher"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_arc_launcher" ]
	file.carePackageWeaponMods["mp_weapon_mgl"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_mgl" ]
	file.carePackageWeaponMods["mp_weapon_rocket_launcher"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_rocket_launcher" ]
	file.carePackageWeaponMods["mp_weapon_defender"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_defender" ]

	// pistol
	file.carePackageWeaponMods["mp_weapon_autopistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_autopistol" ]
	file.carePackageWeaponMods["mp_weapon_semipistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_semipistol" ]
	file.carePackageWeaponMods["mp_weapon_smart_pistol"] <- [] 
	file.carePackageWeaponMods["mp_weapon_wingman"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_wingman" ]
	file.carePackageWeaponMods["mp_weapon_wingman_n"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", ]
	file.carePackageWeaponMods["mp_weapon_shotgun_pistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", ] 

	// sniper
	file.carePackageWeaponMods["mp_weapon_doubletake"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "ricochet" ]
	file.carePackageWeaponMods["mp_weapon_sniper"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "ricochet", "pas_fast_swap", "burn_mod_sniper" ]
	file.carePackageWeaponMods["mp_weapon_dmr"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads" ] 
	
	// rifle
	file.carePackageWeaponMods["mp_weapon_vinson"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_rspn101"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_rspn101_og"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_g2"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_hemlok"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 

	// smg
	file.carePackageWeaponMods["mp_weapon_car"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_alternator_smg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_hemlok_smg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_r97"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 

	// launcher
	file.carePackageWeaponMods["mp_weapon_epg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 
	file.carePackageWeaponMods["mp_weapon_softball"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 
	file.carePackageWeaponMods["mp_weapon_smr"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "burn_mod_smr" ] 
	file.carePackageWeaponMods["mp_weapon_pulse_lmg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 

	// lmg
	file.carePackageWeaponMods["mp_weapon_lmg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "redline_sight" ] 
	file.carePackageWeaponMods["mp_weapon_lstar"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "redline_sight", "reloadanimtest" ] // will have a halfed reload animation! 
	file.carePackageWeaponMods["mp_weapon_esaw"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "redline_sight" ] 
}

void function InitDefaultNPCWeapons()
{
	// pilot weapons
	array<string> pilotMainWeapons =
	[ // try to make this all anti-titans? or grenadiers idk
		"mp_weapon_rspn101_og", 
		"mp_weapon_r97", 
		"mp_weapon_car",
		"mp_weapon_alternator_smg",
		"mp_weapon_vinson" ,
		"mp_weapon_epg",
		//"mp_weapon_smr",
		//"mp_weapon_defender",
		//"mp_weapon_mgl",
		//"mp_weapon_rocket_launcher"
	]
	array<string> pilotAntiTitanWeapons = 
	[ 
		//"mp_weapon_defender", 
		"mp_weapon_rocket_launcher",
		"mp_weapon_mgl",
		"mp_weapon_arc_launcher", // modded, they can now be used by npcs
		"mp_weapon_defender"
	]

	// grunt weapons
	array<string> gruntMainWeapons =
	[
		"mp_weapon_r97", 
		"mp_weapon_rspn101", 
		"mp_weapon_lmg", 
		"mp_weapon_dmr"
	]

	// spectre weapons
	array<string> spectreMainWeapons =
	[
		"mp_weapon_mastiff", 
		"mp_weapon_doubletake", 
		"mp_weapon_hemlok_smg"
	]

	// stalker weapons
	array<string> stalkerMainWeapons =
	[
		"mp_weapon_mastiff", 
		"mp_weapon_hemlok_smg",
		"mp_weapon_lstar"
	]

	// pilot
	file.npcMainWeaponsTable[ "npc_pilot_elite" ] <- pilotMainWeapons
	file.npcAntiTitanWeaponsTable[ "npc_pilot_elite" ] <- pilotAntiTitanWeapons
	// grunt
	file.npcMainWeaponsTable[ "npc_soldier" ] <- gruntMainWeapons
	// spectre
	file.npcMainWeaponsTable[ "npc_spectre" ] <- spectreMainWeapons
	// stalker
	file.npcMainWeaponsTable[ "npc_stalker" ] <- stalkerMainWeapons
}

void function KilledNPCPilotScoreEvent( entity pilot, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( !IsValid( attacker ) )
		return
	if( !attacker.IsPlayer() )
		return
	AddPlayerScore( attacker, "EliminatePilot", pilot )
}

void function ExtraSpawner_SetNPCWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcMainWeaponsTable ) )
		file.npcMainWeaponsTable[ npcClass ] <- []
	file.npcMainWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCAntiTitanWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcAntiTitanWeaponsTable ) )
		file.npcAntiTitanWeaponsTable[ npcClass ] <- []
	file.npcAntiTitanWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetCarePackageWeapons( array<string> weapons )
{
	file.carePackageWeapons = weapons
}

// this can only set a single weapon's mod
void function ExtraSpawner_SetCarePackageWeaponMods( string weaponName, array<string> weaponMods )
{
	if ( !( weaponName in file.carePackageWeaponMods ) )
		file.carePackageWeaponMods[weaponName] <- weaponMods
	else
		file.carePackageWeaponMods[weaponName] = weaponMods
}

// this will reset the whole table
void function ExtraSpawner_SetCarePackageWeaponModsMultiple( table< string, array<string> > weaponModsTable )
{
	file.carePackageWeaponMods = weaponModsTable
}

//------------------------------------------------------

bool function CC_SpawnPilotAndTitan( entity player, array<string> args )
{   
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
		
    Point dropPoint = GetTitanReplacementPoint( player )
	//thread ExtraSpawner_SpawnBTWithCooper( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
	//thread ExtraSpawner_SpawnMonarchWithSarah( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
	//thread ExtraSpawner_SpawnRoninWithAsh( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
   	//thread ExtraSpawner_SpawnLegionWithBlisk( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
	thread ExtraSpawner_SpawnPilotCanEmbark( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
	return true
}

bool function CC_SpawnReaperCanLaunchTicks( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	Point dropPoint = GetTitanReplacementPoint( player )
    thread ExtraSpawner_SpawnReaperCanLaunchTicks( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
    return true
}

bool function CC_SpawnGunShip( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	Point dropPoint = GetTitanReplacementPoint( player )
    thread ExtraSpawner_SpawnGunShip( dropPoint.origin + < 0,0,100 >, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
    return true
}

bool function CC_SpawnAssassinPilot( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity pilot = CreateNPC( "npc_pilot_elite", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_AISettings( pilot, "npc_pilot_elite_assassin" )
	pilot.s.petTitan <- null // initializing
	pilot.s.nextTitanRespawnAvailable <- null

	// many things below should have a reference in _ai_pilots.gnut, for npc pilots ejecting
	asset modelAsset = NPC_PILOT_ALLOWED_MODELS[ RandomInt(NPC_PILOT_ALLOWED_MODELS.len()) ]
	pilot.SetValueForModelKey( modelAsset )
	pilot.SetModel( modelAsset )//

	DispatchSpawn( pilot ) // don't delayed dispatchSpawn()
	pilot.SetModel( modelAsset )
	ExtraSpawner_SetUpNPCPilot( pilot )

	return true
}

bool function CC_SpawnSpecialistGrunt( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity grunt = CreateNPC( "npc_soldier", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_AISettings( grunt, "npc_soldier_pve_specialist" )

	DispatchSpawn( grunt ) // don't delayed dispatchSpawn()
	grunt.SetModel( $"models/robots/spectre/imc_spectre.mdl" )

	return true
}

bool function CC_SpawnPilotElite( entity player, array<string> args )
{   
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	
	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
   
	ExtraSpawner_SpawnPilotElite( pos, rot, GetPlayerAISpawnTeam( player, args ) )
    return true
}

// utility
int function GetPlayerAISpawnTeam( entity player, array<string> args )
{
	int team = TEAM_UNASSIGNED
	if( IsFFAGame() )
		team = TEAM_BOTH // so this ai won't have any teammates
    else
		team = GetOtherTeam( player.GetTeam() )

	if( args.len() > 0 )
	{
		if( args[0] == "sameteam" ) // spawn as teammate
			team = player.GetTeam()
	}

	return team
}

//------------------------------------------------------

// copied from cl_replacement_titan_hud.gnut
void function HotDrop_Spawnpoint( vector origin, int team, float impactTime, bool hasFriendlyWarning = false )
{
	array<entity> targetEffects = []
	vector surfaceNormal = < 0, 0, 1 >

	int index = GetParticleSystemIndex( $"P_ar_titan_droppoint" )

	if( hasFriendlyWarning || FriendlyFire_IsEnabled() ) // also warn friendly players, if we enabled friendly fire...
	{
		entity effectFriendly = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
		SetTeam( effectFriendly, team )
		EffectSetControlPointVector( effectFriendly, 1, FRIENDLY_COLOR_FX )
		effectFriendly.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
		effectFriendly.DisableHibernation()
		targetEffects.append( effectFriendly )
	}

	entity effectEnemy = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
	SetTeam( effectEnemy, team )
	EffectSetControlPointVector( effectEnemy, 1, ENEMY_COLOR_FX )
	effectEnemy.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	effectEnemy.DisableHibernation()
	targetEffects.append( effectEnemy )

	wait impactTime

	foreach( entity targetEffect in targetEffects )
	{
		if ( IsValid( targetEffect ) )
			EffectStop( targetEffect )
	}
}

void function ExtraSpawner_SetUpNPCWeapons( entity npc )
{
	string className = npc.GetClassName()
	
	array<string> mainWeapons
	array<string> antiTitanWeapons
	if ( className in file.npcMainWeaponsTable )
		mainWeapons = file.npcMainWeaponsTable[ className ]
	if ( className in file.npcAntiTitanWeaponsTable )
		antiTitanWeapons = file.npcAntiTitanWeaponsTable[ className ]
	
	if ( mainWeapons.len() == 0 && antiTitanWeapons.len() == 0 ) // no valid weapons
		return

	if ( mainWeapons.len() > 0 )
		ReplaceWeapon( npc, mainWeapons[ RandomInt( mainWeapons.len() ) ], [] )
	if ( antiTitanWeapons.len() > 0 )
		npc.GiveWeapon( antiTitanWeapons[ RandomInt( antiTitanWeapons.len() ) ] )
	
	foreach ( entity weapon in npc.GetMainWeapons() )
		weapon.AddMod( "extra_spawner_ai_weapon" ) // shared mod, if a weapon's keyvalue has this mod, we'll use it
}

// entity.ReplaceActiveWeapon gave grunts archers sometimes, this is my replacement for it
void function ReplaceWeapon( entity guy, string weapon, array<string> mods )
{
	guy.TakeActiveWeapon()
	guy.GiveWeapon( weapon, mods )
	guy.SetActiveWeaponByName( weapon )
}

void function LaunchDropPodThenActivate( entity pod, array<entity> npcs, vector pos, vector rot, bool doDeployAnims = true )
{
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	if ( doDeployAnims )
		ActivateFireteamDropPod( pod, npcs )
	else
	{
		thread DropPodActiveThink( pod )
		foreach ( entity npc in npcs )
		{
			if ( IsAlive( npc ) )
				npc.ClearParent()
		}
	}
}

// so you can set up a titan without have to make a npc pilot embarking it
void function ExtraSpawner_SetUpTitanSeatedPilot( entity titan, int team, int pilotHealth = 250, bool pilotInvulnerable = false, asset pilotModel = $"", string pilotTitle = "鐵馭" )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return

	// mark as having a pilot valid
	titanSoul.soul.seatedNpcPilot.isValid				= true
	titanSoul.soul.seatedNpcPilot.team 					= team

	if ( pilotModel == $"" ) // if no model given, we use a random one
		pilotModel = NPC_PILOT_ALLOWED_MODELS[ RandomInt( NPC_PILOT_ALLOWED_MODELS.len() ) ]
	titanSoul.soul.seatedNpcPilot.modelAsset 			= pilotModel
	titanSoul.soul.seatedNpcPilot.title 				= pilotTitle

	titanSoul.soul.seatedNpcPilot.isInvulnerable		= pilotInvulnerable

	titanSoul.soul.seatedNpcPilot.health				= pilotHealth

	// set up weapons
	array<string> mainWeapons = file.npcMainWeaponsTable[ "npc_pilot_elite" ]
	array<string> antiTitanWeapons = file.npcAntiTitanWeaponsTable[ "npc_pilot_elite" ]
	NPCPilotWeaponStruct weaponStruct
	// main weapon
	if ( mainWeapons.len() > 0 )
	{
		weaponStruct.weaponName = mainWeapons[ RandomInt( mainWeapons.len() ) ]
		titanSoul.soul.seatedNpcPilot.weapons.append( weaponStruct )
	}
	// anti-titan
	if ( antiTitanWeapons.len() > 0 )
	{
		weaponStruct.weaponName = antiTitanWeapons[ RandomInt( antiTitanWeapons.len() ) ]
		titanSoul.soul.seatedNpcPilot.weapons.append( weaponStruct )
	}
}

// utilities end

// copied from _ai_gamemodes, make them compatible with more settings
void function ExtraSpawner_SpawnDropShip( vector pos, vector rot, int team, int count, void functionref( array<entity> guys ) squadHandler = null )
{  
	string squadName = MakeSquadName( team, UniqueString( "" ) )

	CallinData drop
	drop.origin 		= pos
	drop.yaw 			  = rot.y
	drop.dist 			= 768
	drop.team 			= team
	drop.squadname 	= squadName
	SetDropTableSpawnFuncs( drop, CreateSoldier, count )
	SetCallinStyle( drop, eDropStyle.ZIPLINE_NPC )
  
	thread RunDropshipDropoff( drop )
	
	WaitSignal( drop, "OnDropoff" )
	
	array< entity > guys = GetNPCArrayBySquad( squadName )
	
	foreach ( guy in guys )
	{
		ExtraSpawner_SetUpNPCWeapons( guy )
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
}


void function ExtraSpawner_SpawnDropPod( vector pos, vector rot, int team, string content /*( ͡° ͜ʖ ͡°)*/, void functionref( array<entity> guys ) squadHandler = null )
{
	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> guys
	
	entity pod = CreateDropPod( pos, <0,0,0> )
	
	InitFireteamDropPod( pod )
	
	for ( int i = 0; i < 4 ;i++ )
	{
		entity npc = CreateNPC( content, team, pos, <0,0,0> )
		DispatchSpawn( npc )
		SetSquad( npc, squadName )
		
		ExtraSpawner_SetUpNPCWeapons( npc )
		
		npc.SetParent( pod, "ATTACH", true )
		
		npc.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guys.append( npc )
	}
	
	// The order here is different so we can show on minimap while were still falling
	if ( squadHandler != null )
		thread squadHandler( guys )
		
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )
	
	ActivateFireteamDropPod( pod, guys )
}

entity function ExtraSpawner_SpawnTitanRandom( vector pos, vector rot, int team, bool standUp = true, void functionref( entity titan ) titanHandler = null )
{
	// should always keep up with max titans, best way is to use a table, < titanName, titanLoadoutFunction >, added by the callback ExtraSpawner_AddToRandomTitanList()
	int randomindex = RandomInt( 7 )
	string setfile = ""
	string aiset = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	string moddedTitanName = ""
	switch( randomindex ) //randomindex, sometimes changed for test
	{
		case 0:
			setfile = "titan_atlas_stickybomb"
			aiset = "npc_titan_atlas_stickybomb"
			executionRef = "execution_ion" // was "execution_random_0", but ion's prime execution is bugged( maybe because using laser core will trigger a scripted animation? try to fix but not work )
			break
		case 1:
			setfile = "titan_ogre_meteor"
			aiset = "npc_titan_ogre_meteor"
			executionRef = "execution_scorch" // was "execution_random_1", now prime execution are splited for modded titans
			break
		case 2:
			setfile = "titan_stryder_sniper"
			aiset = "npc_titan_stryder_sniper"
			executionRef = "execution_northstar" // was "execution_random_2", now prime execution are splited for modded titans
			break
		case 3:
			setfile = "titan_stryder_leadwall"
			aiset = "npc_titan_stryder_leadwall"
			executionRef = "execution_ronin" // was "execution_random_3", now prime execution are splited for modded titans
			break
		case 4:
			setfile = "titan_atlas_tracker"
			aiset = "npc_titan_atlas_tracker"
			executionRef = "execution_tone" // was "execution_random_4", now prime execution are splited for modded titans
			break
		case 5:
			setfile = "titan_ogre_minigun"
			aiset = "npc_titan_ogre_minigun"
			executionRef = "execution_legion" // was "execution_random_5", now prime execution are splited for modded titans
			break
		case 6:
			setfile = "titan_atlas_vanguard"
			aiset = "npc_titan_atlas_vanguard" 
			executionRef = "execution_vanguard" // was "execution_random_5", has been splited to sarah boss titan
			break
		// modded titans, should avoid them being able to be robbed
		case 7:
			setfile = "titan_atlas_stickybomb"
			aiset = "npc_titan_auto_atlas_ion_prime"
			executionRef = "execution_ion" // ion's prime execution is bugged( maybe because using laser core will trigger a scripted animation? try to fix but not work )
			moddedTitanName = "archon" // hardcoded for now, should split into file.randomTitanList
			break
		case 8:
			setfile = "titan_stryder_sniper"
			aiset = "npc_titan_auto_stryder_northstar_prime"
			executionRef = "execution_northstar_prime"
			moddedTitanName = "brute4" // hardcoded for now
			break
	} 
	foreach ( entity player in GetPlayerArrayOfTeam( team ) )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	thread HotDrop_Spawnpoint( pos, team, 5.0 )

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiset )
    titan.ai.titanSpawnLoadout.setFile = setfile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	DispatchSpawn( titan )

	// titan won't have a soul until they DispatchSpawn()
	titan.GetTitanSoul().soul.titanLoadout.titanExecution = executionRef //"execution_vanguard_kit" // handle in melee_synced_titan to use random execution
	if ( moddedTitanName != "" ) // modded titan!!
		BecomeModdedNPCTitan( titan, moddedTitanName )
	thread NPCTitanHotdrops( titan, standUp )

	if ( titanHandler != null )
		thread titanHandler( titan )

	return titan
}

// hardcoded for now, should split into struct
/*
struct RandomTitanStruct
{
	string setFile
	string aiSettings
	string executionRef = ""
	void functionref( entity ) loadoutFunction = null
}
*/
void function BecomeModdedNPCTitan( entity titan, string moddedTitanName )
{
	switch( moddedTitanName )
	{
		case "archon":
			TakeAllWeapons( titan )
			//Defence
			titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex", "shock_shield"] )
			//Tactical
			titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["tesla_node"] )
			//Offence
			titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["charge_ball"] )
			//Weapon
			titan.GiveWeapon ("mp_titanweapon_sniper", ["arc_cannon", "archon_arc_cannon", "archon_arc_cannon_charge_sound"])
			//Titan Core
			titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["storm_core"] )
			//Melee
			titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )

			titan.SetTitle( "執政官" )
			break
		case "brute4":
			TakeAllWeapons( titan )
			//Defence
			titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_bubble_shield"] )
			//Tactical
			titan.GiveOffhandWeapon("mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO )
			//Offence
			titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["grenade_launcher"] )
			//Weapon
			titan.GiveWeapon ("mp_titanweapon_rocketeer_rocketstream", ["brute4_rocket_launcher"])
			//Titan Core
			titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["barrage_core"] )
			//Melee
			titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

			titan.SetTitle( "野獸四號" )
			break
	}
}

void function ExtraSpawner_SpawnTitanBT( vector pos, vector rot, int team, void functionref( entity titan ) titanHandler = null )
{
	foreach ( entity player in GetPlayerArray() )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	string squadName = MakeSquadName( team, UniqueString( "ZiplineTable" ) )
	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, "npc_titan_buddy")
	SetSpawnOption_Titanfall( titan )
	SetSpawnOption_Warpfall( titan )
	SetSpawnOption_NPCTitan( titan, TITAN_HENCH )
    titan.ai.titanSpawnLoadout.setFile = "titan_buddy"
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )
	DispatchSpawn( titan )
	titan.SetSkin(1)
	SetSquad( titan, squadName )

	if ( titanHandler != null )
		thread titanHandler( titan )
}

// boss titans
entity function ExtraSpawner_SpawnBTWithCooper( vector pos, vector rot, int team )
{
	string setfile = "titan_buddy"
	string aiset = "npc_titan_buddy"
	string executionRef = "execution_bt" // funny with MeleeSyncedNPC

	foreach ( entity player in GetPlayerArrayOfTeam( team ) )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	thread HotDrop_Spawnpoint( pos, team, 5.0 )

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiset )
    titan.ai.titanSpawnLoadout.setFile = setfile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	DispatchSpawn( titan )

	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["arc_rounds"] ) // use the arc-rounds monarch xo16

	// titan won't have a soul until they DispatchSpawn()
	entity titanSoul = titan.GetTitanSoul()
	titanSoul.soul.titanLoadout.titanExecution = executionRef // "execution_bt" now handle in melee_synced_titan to use random execution
	// bt require a "squad" to spawn
	string squadName = MakeSquadName( titan.GetTeam(), UniqueString( "ZiplineTable" ) )
	SetSquad( titan, squadName )
	Rodeo_SetTitanRodeoSequenceEnabled( titan, false ) // so bt won't be able to remove battery

	thread NPCTitanHotdrops( titan, true )

	// jack cooper settings!
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1500, false, $"models/humans/heroes/mlt_hero_jack.mdl", "#PATCH_PILOT2" )

	titan.SetTitle( "#NPC_BT_NAME" )
	titan.SetBehaviorSelector( "behavior_mp_auto_titan_enhanced" ) // become smarter, since pilot has control of it
	SetDefaultMPEnemyHighlight( titan ) // set up highlight after changing behavior
	thread ExtraSpawner_TitanHandler( titan )

	return titan
}

entity function ExtraSpawner_SpawnRoninWithAsh( vector pos, vector rot, int team )
{
	string setfile = "titan_stryder_leadwall"
	string aiset = "npc_titan_stryder_leadwall_boss_fd"
	string executionRef = "execution_ronin_prime" // funny with MeleeSyncedNPC

	foreach ( entity player in GetPlayerArrayOfTeam( team ) )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	thread HotDrop_Spawnpoint( pos, team, 5.0 )

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiset )
    titan.ai.titanSpawnLoadout.setFile = setfile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	DispatchSpawn( titan )

	// titan won't have a soul until they DispatchSpawn()
	entity titanSoul = titan.GetTitanSoul()
	titanSoul.soul.titanLoadout.titanExecution = executionRef
	thread NPCTitanHotdrops( titan, true )

	// ash settings!
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1500, false, $"models/Humans/heroes/imc_hero_ash.mdl", "#BOSSNAME_ASH" )

	titan.SetTitle( "#BOSSNAME_ASH" )
	titan.SetBehaviorSelector( "behavior_mp_auto_titan_enhanced" ) // become smarter, since pilot has control of it
	SetDefaultMPEnemyHighlight( titan ) // set up highlight after changing behavior
	thread ExtraSpawner_TitanHandler( titan )

	return titan
}

entity function ExtraSpawner_SpawnLegionWithBlisk( vector pos, vector rot, int team )
{
	string setfile = "titan_ogre_minigun"
	string aiset = "npc_titan_ogre_minigun_boss_fd"
	string executionRef = "execution_legion_prime" // funny with MeleeSyncedNPC

	foreach ( entity player in GetPlayerArrayOfTeam( team ) )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	thread HotDrop_Spawnpoint( pos, team, 5.0 )

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiset )
    titan.ai.titanSpawnLoadout.setFile = setfile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	DispatchSpawn( titan )

	// titan won't have a soul until they DispatchSpawn()
	entity titanSoul = titan.GetTitanSoul()
	titanSoul.soul.titanLoadout.titanExecution = executionRef
	thread NPCTitanHotdrops( titan, true )

	// blisk settings!
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1500, false, $"models/Humans/heroes/imc_hero_blisk.mdl", "#BOSSNAME_BLISK" )

	titan.SetTitle( "#BOSSNAME_BLISK" )
	titan.SetBehaviorSelector( "behavior_mp_auto_titan_enhanced" ) // become smarter, since pilot has control of it
	SetDefaultMPEnemyHighlight( titan ) // set up highlight after changing behavior
	thread ExtraSpawner_TitanHandler( titan )

	return titan
}

entity function ExtraSpawner_SpawnMonarchWithSarah( vector pos, vector rot, int team )
{
	string setfile = "titan_atlas_vanguard"
	string aiset = "npc_titan_atlas_vanguard_boss_fd"
	string executionRef = "execution_vanguard_kit" // funny with MeleeSyncedNPC

	foreach ( entity player in GetPlayerArrayOfTeam( team ) )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	thread HotDrop_Spawnpoint( pos, team, 5.0 )

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiset )
    titan.ai.titanSpawnLoadout.setFile = setfile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	DispatchSpawn( titan )

	titan.TakeWeaponNow( "mp_titanweapon_xo16_vanguard" )
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["battle_rifle", "battle_rifle_icon"] )

	// titan won't have a soul until they DispatchSpawn()
	entity titanSoul = titan.GetTitanSoul()
	titanSoul.soul.titanLoadout.titanExecution = executionRef
	thread NPCTitanHotdrops( titan, true )

	// sarah settings!
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1500, false, $"models/humans/heroes/mlt_hero_sarah.mdl", "#FACTION_LEADER_NAME_SARAH" )

	titan.SetTitle( "#FACTION_LEADER_NAME_SARAH" )
	titan.SetBehaviorSelector( "behavior_mp_auto_titan_enhanced" ) // become smarter, since pilot has control of it
	SetDefaultMPEnemyHighlight( titan ) // set up highlight after changing behavior
	thread ExtraSpawner_TitanHandler( titan )

	return titan
}

entity function ExtraSpawner_SpawnTitanWithPilot( vector pos, vector rot, int team )
{
	entity titan = ExtraSpawner_SpawnTitanRandom( pos, rot, team )

	// titan won't have a soul until they DispatchSpawn()
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1000, false, $"", "#NPC_PILOT" ) // can use a localized string since this pilot won't embark
	
	titan.SetTitle( "#NPC_PILOT" )
	titan.SetBehaviorSelector( "behavior_mp_auto_titan_enhanced" ) // become smarter, since pilot has control of it
	SetDefaultMPEnemyHighlight( titan ) // set up highlight after changing behavior
	thread ExtraSpawner_TitanHandler( titan ) // forced handler
	return titan
}

void function ExtraSpawner_SpawnNPCInDropPod( vector pos, vector rot, int team, string content )
{
	entity pod = CreateDropPod( pos, <0,0,0> )

    entity spawnNpc = CreateNPC( content, team, pos, rot )
	spawnNpc.EndSignal( "OnDestroy" )
	DispatchSpawn( spawnNpc ) // never delayed dispatchSpawn()

    InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // for fast dissolve
	spawnNpc.SetParent( pod, "ATTACH", true )
	waitthread LaunchDropPodThenActivate( pod, [spawnNpc], pos, rot, false )
}

void function ExtraSpawner_SpawnSpecialistGruntDropPod( vector pos, vector rot, int team, string content, string leaderAiSet = "npc_soldier_pve_specialist", int leaderHealth = 350, void functionref( array<entity> guys ) squadHandler = null )
{
	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> guys
	
	entity pod = CreateDropPod( pos, <0,0,0> )
	
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // for fast dissolve
	
	for ( int i = 0; i < 4 ;i++ )
	{
		entity npc
		if ( i == 0 ) // specialist as leader
			npc = ExtraSpawner_SpawnSpecialistGrunt( pos, <0,0,0>, team, leaderAiSet, leaderHealth )
		else
		{
			npc = CreateNPC( content, team, pos, <0,0,0> )
			DispatchSpawn( npc )
		}

		SetSquad( npc, squadName )
		
		ExtraSpawner_SetUpNPCWeapons( npc )
		
		npc.SetParent( pod, "ATTACH", true )
		
		npc.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guys.append( npc )
	}
	
	// The order here is different so we can show on minimap while were still falling
	if ( squadHandler != null )
		thread squadHandler( guys )
		
	waitthread LaunchDropPodThenActivate( pod, guys, pos, rot )
}

entity function ExtraSpawner_SpawnSpecialistGrunt( vector pos, vector rot, int team, string aiSet = "npc_soldier_pve_specialist", int maxHealth = 350 )
{
	entity npc = CreateNPC( "npc_soldier", team, pos, rot )
	SetSpawnOption_AISettings( npc, aiSet )
	npc.SetMaxHealth( maxHealth ) // same as shield captain
	npc.SetHealth( maxHealth )

	DispatchSpawn( npc )
	// hardcoded here..
	if ( aiSet == "npc_soldier_pve_specialist" )
	{
		if ( team == TEAM_MILITIA )
			npc.SetModel( $"models/humans/heroes/mlt_hero_barker.mdl" )
		else
			npc.SetModel( $"models/humans/heroes/imc_hero_marder.mdl" )
	}
	if ( aiSet == "npc_soldier_shield_captain" )
		npc.SetModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )

	return npc
}

void function ExtraSpawner_SpawnGunShip( vector pos, vector rot, int team )
{
	entity gunship = CreateNPC("npc_gunship", team, pos, rot )
	HideName( gunship ) // won't make it's info target( or health bar ) teleport into battle
	DispatchSpawn( gunship )
	thread PlayAnim( gunship , "st_AngelCity_IMC_Win_ComeIn")
    WaittillAnimDone( gunship )
	ShowName( gunship ) // show info target again
	vector spawnpoint = gunship.GetOrigin()
	vector spawnang = gunship.GetAngles()
	if ( IsValid( gunship ) )
		gunship.Destroy()
	entity gunship2 = CreateNPC("npc_gunship", team, spawnpoint, spawnang )
	SetDefaultMPEnemyHighlight( gunship2 )
	DispatchSpawn( gunship2 )
	if ( CoinFlip() )
	{
		gunship2.TakeWeaponNow( "mp_weapon_gunship_missile" )
		gunship2.GiveWeapon( "mp_weapon_gunship_turret" ) // removed [ "npc_elite_weapon" ]
		gunship2.SetActiveWeaponByName( "mp_weapon_gunship_turret" )
	}
	else
	{
		gunship2.TakeWeaponNow( "mp_weapon_gunship_missile" )
		gunship2.GiveWeapon( "mp_weapon_gunship_missile" ) // removed [ "npc_elite_weapon" ]
		gunship2.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	}

}

void function ExtraSpawner_SpawnPilotCanEmbark( vector pos, vector rot, int team )
{
	// a dummy pod for getting droppod impact time
	float podLaunchTime = expect float ( GetDropPodAnimDuration() )

	entity pilot = ExtraSpawner_SpawnPilotElite( pos, rot, team )
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	pilot.EnableNPCFlag( NPC_IGNORE_ALL ) // so they will mostly try to embark, clean it up later
	// attach to a droppod
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // for fast dissolve
	pilot.SetParent( pod, "ATTACH", true )
	thread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	wait 3 // send titan a little bit later
	entity titan = ExtraSpawner_SpawnTitanForPilot( pilot, pos, rot )
	thread ForceStartTitan( titan, pilot, 10 ) // to fit ownerLifeTimeCheck(), if pilot died instantly we stand the titan
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	wait podLaunchTime - 2.5 // wait for pod launch complete( wait 0.5s more )
	ActivateFireteamDropPod( pod, [ pilot ] )
	thread PilotSpawnProtection( pilot, titan, 15 ) // at least don't let players kill pilots while their titans're not landing

	OnThreadEnd( 
		function(): ( pilot, titan )
		{
			if( !IsAlive( titan ) )
				return
			if( !IsAlive( pilot ) )
			{
				thread StandUnboardedTitan( titan )
				return
			}
		}
	)

	NpcPilotSetPetTitan( pilot, titan )
	titan.SetTitle( pilot.GetTitle() + " 的自動泰坦" )
	titan.WaitSignal( "TitanHotDropComplete" )
	
	thread NpcPilotRunsToEmbarkTitan( pilot, titan )
	pilot.SetNPCMoveSpeedScale( 1.8 ) // want this pilot run to titan's start point faster
	wait 2.0
	
	waitthread NpcPilotRunsToEmbarkTitan( pilot, titan )
	
	thread NpcPilotEmbarksTitan( pilot, titan )
}

void function StandUnboardedTitan( entity titan, bool doHandler = false )
{
	titan.EndSignal( "OnDestroy" )

	waitthread WaitForHotdropToEnd( titan )
	thread PlayAnimGravity( titan, "at_hotdrop_quickstand" )
	titan.ClearInvulnerable()
	if ( doHandler )
		thread ExtraSpawner_TitanHandler( titan )
}

entity function ExtraSpawner_SpawnPilotElite( vector pos, vector rot, int team )
{
	entity pilot = CreateNPC( "npc_pilot_elite", team, pos, rot )//CreateNPC( "npc_soldier", team, pos, rot )
	pilot.s.petTitan <- null // initializing
	pilot.s.nextTitanRespawnAvailable <- null
	DispatchSpawn( pilot ) // don't delayed dispatchSpawn()

	ExtraSpawner_SetUpNPCPilot( pilot )
	asset modelAsset = NPC_PILOT_ALLOWED_MODELS[ RandomInt(NPC_PILOT_ALLOWED_MODELS.len()) ]
	pilot.SetModel( modelAsset )
	pilot.SetMaxHealth( 1000 )
	pilot.SetHealth( 1000 )
	pilot.SetTitle( "鐵馭" ) // "#NPC_PILOT", using a localized string will cause auto-titan's title to be wrong

	ExtraSpawner_SetUpNPCWeapons( pilot )
	// now using a better setup func
	//ReplaceWeapon( pilot, file.pilotMainWeapons[ RandomInt( file.pilotMainWeapons.len() ) ], [] ) //["npc_elite_weapon"]
	//pilot.GiveWeapon( file.pilotAntiTitanWeapons[ RandomInt( file.pilotAntiTitanWeapons.len() ) ] ) // maybe don't do this?
	// want pilots move faster to their titans
	//pilot.EnableNPCMoveFlag( NPCMF_IGNORE_CLUSTER_DANGER_TIME | NPCMF_PREFER_SPRINT )
	//pilot.DisableNPCMoveFlag( NPCMF_FOLLOW_SAFE_PATHS | NPCMF_INDOOR_ACTIVITY_OVERRIDE )

	return pilot
}

void function ExtraSpawner_SetUpNPCPilot( entity pilot )
{
	pilot.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_FLEE ) // hardcoded!
	pilot.SetNPCMoveSpeedScale( 1.25 ) // want pilots move faster
	pilot.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
	pilot.SetEnemyChangeCallback( OnEnemyChanged_NPCPilotTrySwitchWeapon ) // maybe not a good idea since pilot models don't have "ACT_SWITCH_WEAPON"

	AddEntityCallback_OnDamaged( pilot, NPCPilotDamageAdjustments ) // don't let stepping on easily kill them
	SetDefaultMPEnemyHighlight( pilot )
}

void function PilotSpawnProtection( entity pilot, entity titan, float duration )
{
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" ) // pilot's titan has been robbed?

	pilot.SetInvulnerable()
	OnThreadEnd(
		function(): ( pilot )
		{
			if( IsAlive( pilot ) )
				pilot.ClearInvulnerable()
		}
	)

	wait duration
	//pilot.ClearInvulnerable() // fixed: if pilots're killed before titan lands their titan will stuck in the sky!
}

void function ForceStartTitan( entity titan, entity pilot, float delay )
{
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function():( titan, pilot )
		{
			if( IsAlive( pilot ) )
			{
				if( IsAlive( titan ) )
				{
					titan.SetOwner( pilot )
					NPCFollowsNPC( titan, pilot )
					// shared signals in _ai_pilots.gnut
					pilot.Signal( "StopRunsToEmbark" ) // pilot will still embark if they reached titan
					if( titan.ContextAction_IsBusy() ) // embarking?
						return
					thread ExtraSpawner_PilotHandler( pilot ) // titan will follow the pilot
					pilot.SetNPCMoveSpeedScale( 1.25 ) // reset move speed
					pilot.DisableNPCFlag( NPC_IGNORE_ALL ) // pilot also start scan around

					thread StandUnboardedTitan( titan, true )
				}
			}
			else
			{
				if( IsAlive( titan ) ) // this titan have no owner!!
				{
					if( titan.GetTitanSoul().soul.seatedNpcPilot.isValid )
						return
					thread StandUnboardedTitan( titan, true )
				}
			}
		}
	)

	titan.WaitSignal( "TitanHotDropComplete" )
	wait delay
}

entity function ExtraSpawner_SpawnTitanForPilot( entity pilot, vector pos, vector rot )
{
	// reworked to use an existing function
	entity titan = ExtraSpawner_SpawnTitanRandom( pos, rot, pilot.GetTeam(), false ) // the titan will wait
	NpcPilotSetPetTitan( pilot, titan )

	//thread NPCTitanHotdrops( titan, false )
	thread PetTitanOwnerLifeTimeCheck( titan, pilot ) // avoid titan being stuck in the sky! this happens if pilot died while titan dropping

	return titan
}

void function PetTitanOwnerLifeTimeCheck( entity titan, entity owner )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" )

	table data = {}
	data.dropSuccess <- false

	OnThreadEnd(
		function(): ( titan, data )
		{
			if( data.dropSuccess ) // successfully dropped to ground, maybe it can stand up after owner died
				return
			if( IsValid( titan ) ) 
				titan.Destroy() // ded.
		}
	)

	titan.WaitSignal( "TitanHotDropComplete" )
	data.dropSuccess = true
}

function OnNpcPilotBecomesTitan( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	titan.SetBehaviorSelector( "behavior_mp_auto_titan_enhanced" ) // become smarter, since pilot has control of it
	SetDefaultMPEnemyHighlight( titan )
	// kinda annoying to have a info target all around them.
	//titan.SetAISettings( titan.GetAISettingsName() + "_bounty" ) // so they will show up a health bar, letting players know they're npc pilot controled
	//Highlight_ClearEnemyHighlight( titan ) // this resets highlights in modified sh_highlights
	thread DelayedTitanHandler( titan )
}

void function DelayedTitanHandler( entity titan )
{
	wait 1
	if( IsAlive( titan ) )
	{
		thread ExtraSpawner_TitanHandler( titan )
	}
}

function OnNpcTitanBecomesPilot( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	thread DelayedPilotHandler( pilot )

	if ( IsValid( titan ) ) // disembarking, unfortunatelly this is not featured
	{
		entity titanSoul = titan.GetTitanSoul()
		if( !IsValid( titanSoul ) ) // defensive fix for titan.Destroy() situations
			return
		bool isEjecting = titanSoul.IsEjecting()
		if( isEjecting )
			thread NPCPilotEjectingAnimation( pilot )
		else
			titan.SetBehaviorSelector( "behavior_mp_auto_titan" ) // not ejecting, reset to normal behavior
		SetDefaultMPEnemyHighlight( titan )

		// kinda annoying to have a info target all around them.
		//string aiSetFile = titan.GetAISettingsName()
		//titan.SetAISettings( aiSetFile.slice( 0, aiSetFile.len() - 7 ) ) // not ejecting, back to normal health bar
		//Highlight_ClearEnemyHighlight( titan ) // this resets highlights in modified sh_highlights
	}
}

void function DelayedPilotHandler( entity pilot )
{
	pilot.SetInvulnerable() // protection
	wait 1
	if( IsAlive( pilot ) )
	{
		ExtraSpawner_SetUpNPCPilot( pilot )
		pilot.ClearInvulnerable()
		thread ExtraSpawner_PilotHandler( pilot )
	}
}

void function NPCPilotEjectingAnimation( entity pilot )
{
	pilot.EndSignal( "OnDestroy" )
	
	pilot.Anim_ScriptedPlayActivityByName( "ACT_FALL", true, 0.2 )
	while( true )
	{
		if( pilot.IsOnGround() )
			break

		WaitFrame()
	}
	
	pilot.Anim_Stop()
}

// modified things
//////////////////////////////////////////////////////////
// re-adjust damages for npc pilots!
const int PLAYER_TITAN_MELEE_DAMAGE_NPC_PILOT = 100
const int NPC_TITAN_MELEE_DAMAGE_NPC_PILOT = 300
const int TITAN_SOWRD_DAMAGE_NPC_PILOT = 250
const int TITAN_STEPPING_ON_DAMAGE_NPC_PILOT = 250
void function NPCPilotDamageAdjustments( entity pilot, var damageInfo )
{
	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) )
		return
	if ( !attacker.IsTitan() )
		return

	// titan step
	if( damageSourceID == damagedef_titan_step ) 
		DamageInfo_SetDamage( damageInfo, TITAN_STEPPING_ON_DAMAGE_NPC_PILOT )

	// titan melee
	if( damageType & DF_MELEE )
	{
		// player's titan melee
		if ( attacker.IsPlayer() )
		{
			// ronin sword
			if( damageSourceID == eDamageSourceId.melee_titan_sword ) 
				DamageInfo_SetDamage( damageInfo, TITAN_SOWRD_DAMAGE_NPC_PILOT )
			else
				DamageInfo_SetDamage( damageInfo, PLAYER_TITAN_MELEE_DAMAGE_NPC_PILOT )
		}

		// npc's titan melee
		if( attacker.IsNPC() ) 
			DamageInfo_SetDamage( damageInfo, NPC_TITAN_MELEE_DAMAGE_NPC_PILOT )
	}
}

void function ApplyNormalMeleeIdToNPCTitan( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return
    if( !attacker.IsTitan() )
        return
	if( !TitanHasNpcPilot( attacker ) )
		return
	
	// may no need to handle ronin sword, since ronin sometimes try to step on enemies
	DamageInfo_SetDamageSourceIdentifier( damageInfo, eDamageSourceId.melee_titan_punch )
}

// modified, since WT_ANTITITAN won't work in r2, hardcoded
const array<string> ANTI_TITAN_WEAPONS =
[
	"mp_weapon_defender",
	"mp_weapon_rocket_launcher",
	"mp_weapon_arc_launcher", // can't be used by npcs if vanilla
	"mp_weapon_mgl"
]

void function OnEnemyChanged_NPCPilotTrySwitchWeapon( entity pilot )
{
	entity enemy = pilot.GetEnemy()
	if ( !IsAlive( enemy ) )
		return

	array<entity> weapons = pilot.GetMainWeapons()

	// do we have a weapon to switch to?
	if ( weapons.len() < 2 )
		return

	entity activeWeapon = pilot.GetActiveWeapon()
	bool isHeavyArmorTarget = enemy.GetArmorType() == ARMOR_TYPE_HEAVY

	string weaponToChange = ""
	if( isHeavyArmorTarget )
	{
		// first try to find an appropriate weapon
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			bool isAntiTitan = ANTI_TITAN_WEAPONS.contains( className )
			if( isAntiTitan )
				weaponToChange = className
		}
	}
	else // light unit, switch off anti-titans
	{
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			bool isPrimary = !ANTI_TITAN_WEAPONS.contains( className )
			if( isPrimary )
				weaponToChange = className
		}
	}

	//print( "pilot is ready to change to: " + weaponToChange )
	if ( IsValid( activeWeapon ) )
	{
		if ( activeWeapon.GetWeaponClassName() == weaponToChange ) // already holding this weapon
			return
	}
	
	//print( "pilot changing weapon..." )
	pilot.SetActiveWeaponByName( weaponToChange )
	// don't know why sometimes they have ACT_SWITCH_WEAPON missing, maybe because SelectSchedule_SwitchWeapon?
	DisableWeapons( pilot, [] )
	EnableWeapons( pilot, [] )
}

void function ExtraSpawner_PilotHandler( entity pilot )
{	
	// Setup AI, no need for now
	//pilot.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	
	// First AssaultPoint
	array< entity > points = GetNPCArrayOfEnemies( pilot.GetTeam() )
	vector point
	
	if ( points.len() > 0 )
	{
		point = points[ RandomInt( points.len() ) ].GetOrigin()
		pilot.AssaultPoint( point )
		pilot.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	}
	
	array<entity> players = GetPlayerArrayOfEnemies( pilot.GetTeam() )
	// show on enemy radar
	foreach ( player in players )
		pilot.Minimap_AlwaysShow( 0, player )
	
	//thread AITdm_CleanupBoredNPCThread( guy )
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		wait RandomFloatRange(5.0,15.0) // do wait first
		
		// Check if alive
		if ( !IsAlive( pilot ) )
			return
		
		// Get point and send guy to it
		points = GetNPCArrayOfEnemies( pilot.GetTeam() )
		if ( points.len() == 0 )
			continue
			
		point = points[ RandomInt( points.len() ) ].GetOrigin()
		
		pilot.AssaultPoint( point )
	}

}

void function ExtraSpawner_TitanHandler( entity titan )
{
	// First AssaultPoint
	array< entity > points = GetNPCArrayOfEnemies( titan.GetTeam() )
	vector point
	
	if ( points.len() > 0 )
	{
		point = points[ RandomInt( points.len() ) ].GetOrigin()
		titan.AssaultPoint( point )
		titan.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	}
	
	array<entity> players = GetPlayerArrayOfEnemies( titan.GetTeam() )
	// show on enemy radar
	foreach ( player in players )
		titan.Minimap_AlwaysShow( 0, player )
	
	//thread AITdm_CleanupBoredNPCThread( guy )
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		wait RandomFloatRange(5.0,15.0) // wait first!
	
		// Check if alive
		if ( !IsAlive( titan ) )
			return
		
		// Get point and send guy to it
		points = GetNPCArrayOfEnemies( titan.GetTeam() )
		if ( points.len() == 0 )
			continue
			
		point = points[ RandomInt( points.len() ) ].GetOrigin()
		
		titan.AssaultPoint( point )
	}
}

const float CARE_PACKAGE_LIFETIME = 30
const float CARE_PACKAGE_WAITTIME = 5
void function ExtraSpawner_SpawnCarePackageToGetWeapons( vector pos, vector rot, float lifeTime = CARE_PACKAGE_LIFETIME, float waitTime = CARE_PACKAGE_WAITTIME )
{
	//thread DropWeaponAlert( pos, 500, 200 )
	thread CarePackage_SpawnPoint( pos, 10 )
	thread ExtraSpawner_SpawnCarePackageToGetWeapons_Threaded( pos, rot, lifeTime, waitTime )
}

void function ExtraSpawner_SpawnCarePackageToGetWeapons_Threaded( vector pos, vector rot, float lifeTime, float waitTime )
{
	file.usedplayer.clear()
	wait waitTime
	entity pod = CreateDropPod( pos, <0,0,0> )
	pod.EndSignal( "OnDestroy" )
	Highlight_SetOwnedHighlight( pod, "friendly_ai" )

	//InitFireteamDropPod( pod )

	// it takes 5s to drop
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	pod.SetUsable()
	pod.SetUsableByGroup( "pilot" )
	pod.SetUsePrompts( "按住 %use% 以獲取武器", "按下 %use% 獲取武器" )
	AddCallback_OnUseEntity( pod , GiveAirDropWeapon )

	HighlightDropPod( pod )
	pod.SetModel( CAREPACKAGE_MODEL )
    
    wait lifeTime

	//pod.Destroy()
	pod.UnsetUsable() // don't let dissolving pod able to be used
	pod.NotSolid() // clear collision
	DisableDropPodHighlight( pod )
	pod.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
}

// copied from cl_replacement_titan_hud.gnut
void function CarePackage_SpawnPoint( vector origin, float impactTime )
{
	array<entity> targetEffects = []
	vector surfaceNormal = < 0, 0, 1 >

	int index = GetParticleSystemIndex( $"P_ar_titan_droppoint" )

	entity targetEffect = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
	EffectSetControlPointVector( targetEffect, 1, < 0,190,0 > ) // green
	targetEffect.DisableHibernation()

	wait impactTime

	if ( IsValid( targetEffect ) )
		EffectStop( targetEffect )
}

function GiveAirDropWeapon( pod , player )
{
	expect entity( player )
	vector pos = player.GetOrigin()

	if( file.usedplayer.contains( player ) )
	{
		//SendHudMessage(player, "Once Robbed Weapon from Care Package\nPlease Wait for Next Delivery",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1)
		SendHudMessage( player, "已獲取本次補給艙\n請等待下一輪",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1 )
		return
	}
    //DropModdedWeapons( WEAPONS, pos, MODS )
	if( player.GetMainWeapons().len() == 3 )
		player.DropWeapon( player.GetMainWeapons()[2] ) // was [1], for the newest version, drop the grenadier!
	//GiveModdedWeapons( player, WEAPONS, MODS )
	GiveModdedWeapons( player, file.carePackageWeapons )
	RestorePlayerAmmo( player )
    //SendHudMessage(player, "Got Weapon from Care Package",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1)
    SendHudMessage( player, "已從補給艙補充彈藥",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1 )
	file.usedplayer.append( player )
	player.Signal( "PlayerUsedCarePackage" )
}

// now allowing every weapon to have a custom mod
void function GiveModdedWeapons( entity player, array<string> weapons )
{
	string weaponName = weapons[ RandomInt(weapons.len()) ]
	array<string> mods = []
	if ( weaponName in file.carePackageWeaponMods )
		mods = file.carePackageWeaponMods[weaponName]
	player.GiveWeapon( weaponName, mods )
	player.SetActiveWeaponByName( weaponName )
}

void function RestorePlayerAmmo( entity player )
{
	foreach( entity mainWeapon in player.GetMainWeapons() )
	{
		// this will restore anti-titan's ammo
		try // should do a try-catch for safely adding other classes
		{
			// seriously?! GetWeaponPrimaryAmmoCountMax() only exists on ClientVM
			// use weapon.GetWeaponSettingInt( eWeaponVar.ammo_stockpile_max ) also works!!
			// current restore 3 mags
			//mainWeapon.SetWeaponPrimaryAmmoCount( mainWeapon.GetWeaponPrimaryAmmoCount() + mainWeapon.GetWeaponPrimaryClipCountMax() * 3 )
			// updated, restore all ammo
			mainWeapon.SetWeaponPrimaryAmmoCount( 9999 )
		}
		catch(ex){}
	}
	foreach( entity offhand in player.GetOffhandWeapons() )
	{
		// this will restore ordnances
		try // should do a try-catch for safely adding other classes
		{
			offhand.SetWeaponPrimaryClipCount( offhand.GetWeaponPrimaryClipCountMax() )
		}
		catch(ex){}
	}
}

void function HighlightWeaponAmped( entity weapon )
{
	if ( weapon.IsLoadoutPickup() )
	{
		Highlight_SetOwnedHighlight( weapon, "sp_loadout_pickup" )
		Highlight_SetNeutralHighlight( weapon, "sp_loadout_pickup" )
	}
	else
	{
		Highlight_SetOwnedHighlight( weapon, "enemy_boss_bounty" )
		Highlight_SetNeutralHighlight( weapon, "enemy_boss_bounty" )
	}
}

void function HighlightDropPod( entity pod )
{
	Highlight_SetOwnedHighlight( pod, "enemy_boss_bounty" )
	Highlight_SetNeutralHighlight( pod, "enemy_boss_bounty" )
}

void function DisableDropPodHighlight( entity pod )
{
	Highlight_ClearOwnedHighlight( pod )
	Highlight_ClearNeutralHighlight( pod )
}

const float REAPER_WARPFALL_DELAY = 4.7 // same as fd does
void function ExtraSpawner_SpawnReaperCanLaunchTicks( vector pos, vector rot, int team, string reaperSettings = "npc_super_spectre_aitdm", string tickSettings = "npc_frag_drone" )
{
	// nessie fix
	thread HotDrop_Spawnpoint( pos, team, 6.2 ) 

	wait REAPER_WARPFALL_DELAY
	entity reaper = CreateSuperSpectre( team, pos, rot )
	// reaper highlight
	Highlight_SetFriendlyHighlight( reaper, "sp_enemy_pilot" )
	reaper.Highlight_SetParam( 1, 0, < 1,1,1 > )
	SetDefaultMPEnemyHighlight( reaper )

	SetSpawnOption_Titanfall( reaper )
	SetSpawnOption_Warpfall( reaper )
	
	SetSpawnOption_AISettings( reaper, reaperSettings )
	
	DispatchSpawn( reaper )
	// this has been modified, but northstar don't support stational point for now, write my own one
	//thread ReaperMinionLauncherThink( reaper, tickSettings ) 
	thread ExtraSpawner_ReaperTickLaunchThink( reaper, tickSettings )
	
	thread ExtraSpawner_ReaperHandler( reaper )
}

void function ExtraSpawner_ReaperTickLaunchThink( entity reaper, string tickType )
{
	reaper.EndSignal( "OnDeath" )

	wait 10 // startup time
	while ( true )
	{
		wait RandomFloatRange( 25.0, 40.0 ) // every 25 - 40 secs try to do a tickLaunch, simple right?
		//WaitFrame() // wasn't good! reapers won't launch if they can see their enemies, should keep letting them launch!

		//printt( reaper,"REAPER TICK LAUNCH:", reaper.GetOrigin() )
		waitthread Reaper_LaunchFragDrone_Think( reaper, tickType )
		//printt( reaper,"REAPER END TICK LAUNCH:", reaper.GetOrigin() )
		while ( GetScriptManagedEntArrayLen( reaper.ai.activeMinionEntArrayID ) > 2 )
			WaitFrame()
	}
}

// Same as SquadHandler, just for reapers
void function ExtraSpawner_ReaperHandler( entity reaper )
{
	array<entity> players = GetPlayerArrayOfEnemies( reaper.GetTeam() )
	foreach ( player in players )
		reaper.Minimap_AlwaysShow( 0, player )
	
	reaper.AssaultSetGoalRadius( 500 )
	
	// Every 10 - 20 secs get a player and go to him
	// Definetly not annoying or anything :)
	while( IsAlive( reaper ) )
	{
		players = GetPlayerArrayOfEnemies( reaper.GetTeam() )
		if ( players.len() != 0 )
		{
			entity player = GetClosest2D( players, reaper.GetOrigin() )
			reaper.AssaultPoint( player.GetOrigin() )
		}
		wait RandomFloatRange( 10.0, 20.0 )
	}
	// thread AITdm_CleanupBoredNPCThread( reaper )
}