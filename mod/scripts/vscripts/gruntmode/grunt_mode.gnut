untyped
global function Modded_Gamemode_GruntMode_Init

// npc counts
const SQUADS_PER_TEAM = 6
const REAPERS_PER_TEAM = 2

const MARVINS_PER_TEAM = 4
const PROWLERS_PER_TEAM = 4
const PILOTS_PER_TEAM = 3

const TITANS_PER_TEAM = 0
const GUNSHIPS_PER_TEAM = 2

const float AIRDROP_INTERNAL = 40.0 // fixed! ->// time for each air drops, current hardcoded( for airdrops now dissolves only after certain time )

// escalator
const LEVEL_SPECTRES = 50
const LEVEL_STALKERS = 100
const LEVEL_REAPERS = 180
const LEVEL_GUNSHIPS = 200
const LEVEL_TITANS = 250

// unused
//const array<string> WEAPONS = [ "mp_weapon_alternator_smg", "mp_weapon_arc_launcher", "mp_weapon_autopistol", "mp_weapon_car", "mp_weapon_defender", "mp_weapon_dmr", "mp_weapon_doubletake", "mp_weapon_epg", "mp_weapon_esaw", "mp_weapon_g2", "mp_weapon_hemlok", "mp_weapon_hemlok_smg", "mp_weapon_lmg", "mp_weapon_lstar", "mp_weapon_mastiff", "mp_weapon_mgl", "mp_weapon_pulse_lmg", "mp_weapon_r97", "mp_weapon_rocket_launcher", "mp_weapon_rspn101", "mp_weapon_rspn101_og", "mp_weapon_semipistol", "mp_weapon_shotgun", "mp_weapon_shotgun_pistol", "mp_weapon_smart_pistol", "mp_weapon_smr", "mp_weapon_sniper", "mp_weapon_softball", "mp_weapon_vinson", "mp_weapon_wingman", "mp_weapon_wingman_n" ]
//const array<string> MODS = [ "pas_run_and_gun", "threat_scope", "pas_fast_ads", "pas_fast_reload", "extended_ammo", "pas_fast_swap" ]

// scores
const int PLAYER_SCORE_AMOUNT = 3
const int PLAYER_SPECIALIST_SCORE_AMOUNT = 5
const int PILOT_SCORE_AMOUNT = 5
const int GUNSHIP_SCORE_AMOUNT = 5
const int MARVIN_SCORE_AMOUNT = 1
const int GRUNT_SCORE_AMOUNT = 1
const int SPECTRE_SCORE_AMOUNT = 2
const int STALKER_SCORE_AMOUNT = 2
const int PROWLER_SCORE_AMOUNT = 3
const int REAPER_SCORE_AMOUNT = 5
const int DRONE_SCORE_AMOUNT = 0
const int TITAN_SCORE_AMOUNT = 10

struct
{
	// Due to team based escalation everything is an array
	array< int > levels = [ LEVEL_SPECTRES, LEVEL_SPECTRES ]
	array< array< string > > podEntities = [ [ "npc_soldier" ], [ "npc_soldier" ] ]
	array< bool > reapers = [ false, false ]

	array< bool > marvins = [ false, false ]
	array< bool > prowlers = [ false, false ]
	array< bool > weapondrops = [ false, false ]

	array< bool > gunships = [ false, false ]
	array< bool > pilots = [ false, false ]
	array< bool > titans = [ false, false ]
} file


void function Modded_Gamemode_GruntMode_Init()
{
	// rodeo modifier settings!
	/*
	ClassicRodeo_SetEnabled( true )
	ClassicRodeo_AllowContinouslyRemoveBattery( true ) // so you can rip battery all day long!
	ClassicRodeo_SetBatteryRemovalDamageAmped( true ) // rodeo will deal large damage to titans
	ClassicRodeo_SetAdditionalDamageScale( 1.0 ) // since ripping battery is always, we should also deal additional damage on rodeo to catch up with it
	ClassicRodeo_BatteryContainerOnlyProtectsOnce( false )
	ClassicRodeo_OwnerApplyBatteryAllowed( true )
	ClassicRodeo_SetShouldAutomaticallyDoRodeoSequence( false )
	*/

	BecomesGruntMode_Init() // init everything

	SetSpawnpointGamemodeOverride( ATTRITION ) // use bounty hunt spawns as vanilla game has no spawns explicitly defined for aitdm

	AddCallback_GameStateEnter( eGameState.Prematch, OnPrematchStart )
	AddCallback_GameStateEnter( eGameState.Playing, OnPlaying )

	// these are fully hardcodes, not using
	//AddCallback_OnNPCKilled( HandleScoreEvent )
	//AddCallback_OnPlayerKilled( HandleScoreEvent )

	// scoring
	AddDeathCallback( "player", ForceAddScoreForPlayerOrNPCKill )
	SetEnemyHighlightHide( true ) // this will hide enemy's highlights

	// npc killed score event, using death callbacks for npc killing each other!
	// these two can't be handle by scoreEvents
	AddDeathCallback( "npc_pilot_elite", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_gunship", ForceAddScoreForPlayerOrNPCKill )

	AddDeathCallback( "npc_marvin", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_soldier", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_spectre", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_stalker", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_prowler", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_super_spectre", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_drone", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_titan", ForceAddScoreForPlayerOrNPCKill )
	AddDeathCallback( "npc_drone", ForceAddScoreForPlayerOrNPCKill )

	AddCallback_OnClientConnected( OnPlayerConnected )

	AddCallback_NPCLeeched( OnSpectreLeeched )

	/* // now we're using a real npc pilot spawn
	if ( GetCurrentPlaylistVarInt( "aitdm_archer_grunts", 0 ) == 0 )
	{
		// this one is hardcoded for "pilot" weapons, as only these weapons have the mod "npc_elite_weapon"
		AiGameModes_SetGruntWeapons( [ "mp_weapon_alternator_smg", "mp_weapon_r97", "mp_weapon_car", "mp_weapon_vinson", "mp_weapon_rspn101_og" ] )
		AiGameModes_SetSpectreWeapons( [ "mp_weapon_defender", "mp_weapon_sniper", "mp_weapon_doubletake", "mp_weapon_hemlok_smg" ] )
	}
	else
	{
		AiGameModes_SetGruntWeapons( [ "mp_weapon_rocket_launcher" ] )
		AiGameModes_SetSpectreWeapons( [ "mp_weapon_rocket_launcher" ] )
	}
	*/
	AiGameModes_SetGruntWeapons( [ "mp_weapon_r97", "mp_weapon_rspn101", "mp_weapon_lmg", "mp_weapon_dmr" ] )
	AiGameModes_SetSpectreWeapons( [ "mp_weapon_defender", "mp_weapon_mastiff", "mp_weapon_doubletake", "mp_weapon_hemlok_smg" ] )
	ExtraSpawner_SetGruntWeapons( [ "mp_weapon_r97", "mp_weapon_rspn101", "mp_weapon_lmg", "mp_weapon_dmr" ] )
	ExtraSpawner_SetGruntAntiTitanWeapons( [ "mp_weapon_rocket_launcher", "mp_weapon_mgl" ] )

	ScoreEvent_SetupEarnMeterValuesForMixedModes()

	ClassicMP_ForceDisableEpilogue( true )
	Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
	Riff_ForceTitanAvailability( eTitanAvailability.Never )

	// so you're likely no need to wait so freaking long, !!! tempfix specific
	SetWaitingForPlayersMaxDuration( 10.0 )
    ClassicMP_SetCustomIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )
}

//------------------------------------------------------

void function OnPrematchStart()
{
	thread StratonHornetDogfightsIntense()
}

void function OnPlaying()
{
	// don't run spawning code if ains and nms aren't up to date
	if ( GetAINScriptVersion() == AIN_REV && GetNodeCount() != 0 )
	{
		thread SpawnIntroBatch( TEAM_MILITIA )
		thread SpawnIntroBatch( TEAM_IMC )
	}
}

void function OnPlayerConnected( entity player )
{
	Remote_CallFunction_NonReplay( player, "ServerCallback_AITDM_OnPlayerConnected" )
}

//------------------------------------------------------

void function HandleScoreEvent( entity victim, entity attacker, var damageInfo )
{
	if ( !( victim != attacker && attacker.IsPlayer() || attacker.IsTitan() && attacker.GetBossPlayer() != null && GetGameState() == eGameState.Playing ) ) //add getowner to this since it crash my game everytime when am trying to deploy a npctitan without a owner
		return

	int score
	string eventName

	//if ( victim.IsNPC() && victim.GetClassName() != "npc_marvin" )
	//{
	//	eventName = ScoreEventForNPCKilled( victim, damageInfo )
	//	if ( eventName != "KillNPCTitan"  && eventName != "" )
	//		score = ScoreEvent_GetPointValue( GetScoreEvent( eventName ) )
	//}

	if ( victim.IsPlayer() )
		score = 3

	if ( victim.GetClassName() == "npc_marvin" )
		score = 1

	if ( victim.GetClassName() == "npc_prowler" )
		score = 2

	if ( victim.GetClassName() == "npc_spectre" )
		score = 2

	if ( victim.GetClassName() == "npc_stalker" )
		score = 2

	if ( victim.GetClassName() == "npc_super_spectre" )
		score = 5

	if ( victim.GetClassName() == "npc_soldier" )
		score = 5
	
	if ( victim.GetClassName() == "npc_drone" )
		score = 0

	if ( victim.GetClassName() == "npc_gunship" )
		score = 5

	if( victim.GetModelName() == $"models/humans/grunts/imc_grunt_shield_captain.mdl" || victim.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" )
		score = 5

	// Player ejecting triggers this without the extra check
	if ( victim.IsTitan() && victim.GetBossPlayer() != attacker )
		score += 10

	// make npc able to earn score?
	AddTeamScore( attacker.GetTeam(), score )
	if( !attacker.IsNPC() )
	{
		attacker.AddToPlayerGameStat( PGS_ASSAULT_SCORE, score )
		attacker.SetPlayerNetInt( "AT_bonusPoints", attacker.GetPlayerGameStat( PGS_ASSAULT_SCORE ) )
	}
}

void function ForceAddScoreForPlayerOrNPCKill( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( !IsValid( attacker ) )
		return
	if( !attacker.IsNPC() && !attacker.IsPlayer() ) // not killed by anybody
		return

	if ( attacker == victim ) // suicide!
		return

	// if it's a npc with bossplayer/owner...
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		if ( IsValid( attacker.GetBossPlayer() ) )
			attacker = attacker.GetBossPlayer()
		if ( IsValid( attacker.GetOwner() ) )
			attacker = attacker.GetOwner()
	}

	if ( victim.IsNPC() )
	{
		// if victim is a npc that owned by players, don't add score
		entity bossPlayer = victim.GetBossPlayer()
		entity owner = victim.GetOwner()
		if ( IsValid( bossPlayer ) )
		{
			if ( bossPlayer.IsPlayer() )
				return
		}
		if ( IsValid( owner ) )
		{
			if ( owner.IsPlayer() )
				return
		}
	}

	string className = victim.GetClassName()
	int scoreToAdd = 0
	string scoreEvent = "" // for npcs can't handle by OnNPCKilled(), do a extra score event

	if ( victim.IsPlayer() )
	{
		// consider these are specialist player grunts 
		if( IsGruntModeSpecialistClass( victim ) )
			scoreToAdd = PLAYER_SPECIALIST_SCORE_AMOUNT
		else
			scoreToAdd = PLAYER_SCORE_AMOUNT
	}

	if ( className == "npc_pilot_elite" )
	{
		scoreToAdd = PILOT_SCORE_AMOUNT
		scoreEvent = "EliminatePilot"
	}

	if ( className == "npc_gunship" )
		scoreToAdd = GUNSHIP_SCORE_AMOUNT

	if ( className == "npc_marvin" )
		scoreToAdd = MARVIN_SCORE_AMOUNT

	if ( className == "npc_prowler" )
		scoreToAdd = PROWLER_SCORE_AMOUNT

	if ( className == "npc_spectre" )
		scoreToAdd = SPECTRE_SCORE_AMOUNT

	if ( className == "npc_stalker" )
		scoreToAdd = STALKER_SCORE_AMOUNT

	if ( className == "npc_super_spectre" )
		scoreToAdd = REAPER_SCORE_AMOUNT

	if ( className == "npc_soldier" )
		scoreToAdd = GRUNT_SCORE_AMOUNT
	
	if ( className == "npc_drone" )
		scoreToAdd = DRONE_SCORE_AMOUNT

	// Player ejecting triggers this without the extra check
	if ( victim.IsTitan() && victim.GetBossPlayer() != attacker )
	{
		if ( TitanHasNpcPilot( victim ) ) // pilot was killed without ejecting
		{
			scoreToAdd = TITAN_SCORE_AMOUNT + PILOT_SCORE_AMOUNT
			scoreEvent = "EliminatePilot"
		}
		else // ejected or auto titan
			scoreToAdd = TITAN_SCORE_AMOUNT
	}

	if ( scoreToAdd > 0 )
		AddTeamScore( attacker.GetTeam(), scoreToAdd ) // this can handle both players' and npcs' kills
	if( attacker.IsPlayer() ) // specific for players
	{
		if ( scoreEvent != "" )
			AddPlayerScore( attacker, scoreEvent, victim )
		if ( scoreToAdd > 0 )
		{
			attacker.AddToPlayerGameStat( PGS_ASSAULT_SCORE, scoreToAdd )
			attacker.SetPlayerNetInt( "AT_bonusPoints", attacker.GetPlayerGameStat( PGS_ASSAULT_SCORE ) )
		}
	}
}

//------------------------------------------------------

void function SpawnIntroBatch( int team )
{
	// intro spawn
	for ( int i = 0; i < SQUADS_PER_TEAM; i++ )
	{
		if ( RandomInt( 4 ) > 0 ) // 75% chance of spawning a specialist squad(??
		{
			array< entity > points = SpawnPoints_GetDropPod()
			entity node = points[ GetSpawnPointIndex( points, team ) ]
			// 33% chance of spawning a shield captain
			string leaderSet = RandomInt( 3 ) == 0 ? "npc_soldier_shield_captain" : "npc_soldier_pve_specialist"
			//print( "RUNNING ExtraSpawner_SpawnSpecialistGruntDropPod()" )
			thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, leaderSet, SquadHandler )
			wait 5 // wait 5s per spawn, or player will have model issue since there're too many entities
		}
		else
		{
			array< entity > points = GetZiplineDropshipSpawns()

			// Prefer dropship when spawning grunts
			if ( points.len() / 4 > 0 ) // must have more than 4 points
			{
				entity node = points[ GetSpawnPointIndex( points, team ) ]
				thread AiGameModes_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, 4, SquadHandler )
				wait 10
				continue
			}

			points = SpawnPoints_GetDropPod()
			entity node = points[ GetSpawnPointIndex( points, team ) ]
			thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, "npc_soldier", SquadHandler )
		}
	}


	thread Spawner( team )
	thread SpawnerExtend( team )
	thread SpawnerWeapons( team )
}

// Populates the match
void function Spawner( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			Escalate( team )

			// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
			array<entity> npcs = GetNPCArrayOfTeam( team )
			int count = npcs.len()
			int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()

			// REAPERS
			if ( file.reapers[ index ] )
			{
				array< entity > points = SpawnPoints_GetDropPod()
				if ( reaperCount < REAPERS_PER_TEAM )
				{
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					waitthread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
				}
			}

			// NORMAL SPAWNS
			if ( count < SQUADS_PER_TEAM * 4 - 2 )
			{
				if ( RandomInt( 4 ) > 0 ) // 75% chance of spawning a specialist squad(??
				{
					array< entity > points = SpawnPoints_GetDropPod()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					// 33% chance of spawning a shield captain
					string leaderSet = RandomInt( 3 ) == 0 ? "npc_soldier_shield_captain" : "npc_soldier_pve_specialist"
					//print( "RUNNING ExtraSpawner_SpawnSpecialistGruntDropPod()" )
					thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, leaderSet, SquadHandler )
				}
				else
				{
					string ent = file.podEntities[ index ][ RandomInt( file.podEntities[ index ].len() ) ]

					array< entity > points = GetZiplineDropshipSpawns()

					// Prefer dropship when spawning grunts
					if ( ent == "npc_soldier" && points.len() / 4 > 0 ) // must have more than 4 points
					{
						entity node = points[ GetSpawnPointIndex( points, team ) ]
						waitthread AiGameModes_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, 4, SquadHandler )
						continue
					}

					points = SpawnPoints_GetDropPod()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent, SquadHandler )
				}
			}
		}
		else
			break
		WaitFrame()
	}
}

void function SpawnerExtend( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			Escalate( team )

			int marvinCount = GetNPCArrayEx( "npc_marvin", team, -1, <0,0,0>, -1 ).len()
			int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()
			int gunshipCount = GetNPCArrayEx( "npc_gunship", team, -1, <0,0,0>, -1 ).len()
	        int titanCount = GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()
	        int pilotCount = GetNPCArrayEx( "npc_pilot_elite", team, -1, <0,0,0>, -1 ).len() + GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()


	        // GUNSHIPS
	        if ( file.gunships[ index ] )
			{
				array< entity > points = SpawnPoints_GetDropPod()
				if ( gunshipCount < GUNSHIPS_PER_TEAM )
				{
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					waitthread ExtraSpawner_SpawnGunShip( node.GetOrigin(), node.GetAngles(), team)
				}
			}

			// TITANS
			if ( file.titans[ index ] )
			{
				array< entity > points = SpawnPoints_GetDropPod()
				if ( titanCount < TITANS_PER_TEAM )
				{
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					waitthread ExtraSpawner_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team, true, TitanHandler )
				}
			}

			// PILOTS
			if ( file.pilots[ index ] )
			{
				array< entity > points = SpawnPoints_GetDropPod()
				if ( pilotCount < PILOTS_PER_TEAM )
				{
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team, TitanHandler )
					if ( RandomInt( 5 ) == 0 ) // boss titans has 1/5 chance to spawn
					{
						switch ( RandomInt( 4 ) )
						{
							case 0:
								waitthread ExtraSpawner_SpawnBTWithCooper( node.GetOrigin(), node.GetAngles(), team )
								break
							case 1:
								waitthread ExtraSpawner_SpawnRoninWithAsh( node.GetOrigin(), node.GetAngles(), team )
								break
							case 2:
								waitthread ExtraSpawner_SpawnLegionWithBlisk( node.GetOrigin(), node.GetAngles(), team )
								break
							case 3:
								waitthread ExtraSpawner_SpawnMonarchWithSarah( node.GetOrigin(), node.GetAngles(), team )
								break
						}
					}
					else
						waitthread ExtraSpawner_SpawnPilotCanEmbark( node.GetOrigin(), node.GetAngles(), team )
				}
			}

			// MARVINS
			if ( file.marvins[ index ] )
			{
				string ent = "npc_marvin"
				array< entity > points = SpawnPoints_GetDropPod()
				if ( marvinCount < MARVINS_PER_TEAM )
				{
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//waitthread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
					
				}
			}

			// PROWLERS
			if ( file.prowlers[ index ] )
			{
				string ent = "npc_prowler"
				array< entity > points = SpawnPoints_GetDropPod()
				if ( prowlerCount < PROWLERS_PER_TEAM )
				{
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//waitthread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
					
				}
			}
		}
		else
			break
		WaitFrame()
	}
}

void function SpawnerWeapons( int team )
{
	//svGlobal.levelEnt.EndSignal( "GameStateChanged" )

	while( true )
	{
		wait AIRDROP_INTERNAL
		if( GetGameState() == eGameState.Playing )
		{
			foreach( entity player in GetPlayerArrayOfTeam( team ) )
			{
				NSSendLargeMessageToPlayer( player, "補給艙運送中! ", "補充重火力與武器彈藥，並獲取一把榴彈兵武器", 15, "rui/callsigns/callsign_69_col" )
				//NSSendLargeMessageToPlayer( player, "Delivering Care Package!", "Refill ordnance and weapon ammo, also get a grenadier weapon", 15, "rui/callsigns/callsign_69_col" )
			}
			/* // older version
			foreach( entity player in GetPlayerArray() )
			{
				if( IsValid(player) )
					SendHudMessage(player, "Delivering Care Package",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1)
			}
			*/
			array< entity > points = SpawnPoints_GetDropPod()

			entity node = points[ GetSpawnPointIndex( points, team ) ]
			//waitthread SpawnReaperDorpsWeapons( node.GetOrigin(), node.GetAngles(), WEAPONS, MODS )
			ExtraSpawner_SpawnCarePackageToGetWeapons( node.GetOrigin(), node.GetAngles(), AIRDROP_INTERNAL - 10 ) // carepackages will take 10s to drop
		}
		else
			break
	}
}

// Based on points tries to balance match
void function Escalate( int team )
{
	int score = GameRules_GetTeamScore( team )
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	if ( score < file.levels[ index ] )
		return

	switch ( file.levels[ index ] )
	{
		case LEVEL_SPECTRES:
			file.levels[ index ] = LEVEL_STALKERS
			file.marvins[ index ] = true
			file.podEntities[ index ].append( "npc_spectre" )
			SetGlobalNetInt( defcon, 2 )
			return

		case LEVEL_STALKERS:
			file.levels[ index ] = LEVEL_REAPERS
			file.marvins[ index ] = false
			file.weapondrops[ index ] = true
			file.prowlers[ index ] = true
			file.podEntities[ index ].append( "npc_stalker" )
			SetGlobalNetInt( defcon, 3 )
			return

		case LEVEL_REAPERS:
			file.levels[ index ] = LEVEL_GUNSHIPS
			file.reapers[ index ] = true
			SetGlobalNetInt( defcon, 4 )
			return

        case LEVEL_GUNSHIPS:
			file.levels[ index ] = LEVEL_TITANS
			file.gunships[ index ] = true
			SetGlobalNetInt( defcon, 5 )
			return


		case LEVEL_TITANS:
			file.levels[ index ] = 9999
			file.prowlers[ index ] = false
			file.pilots[ index ] = true
			file.titans[ index ] = true
			SetGlobalNetInt( defcon, 6 )
			return
	}

	unreachable // hopefully
}

//------------------------------------------------------

int function GetSpawnPointIndex( array< entity > points, int team )
{
	entity zone = DecideSpawnZone_Generic( points, team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( points.len() )

			if ( Distance2D( points[ index ].GetOrigin(), zone.GetOrigin() ) < 6000 )
				return index
		}
	}

	return RandomInt( points.len() )
}

//------------------------------------------------------

// tells infantry where to go
// In vanilla there seem to be preset paths ai follow to get to the other teams vone and capture it
// AI can also flee deeper into their zone suggesting someone spent way too much time on this
void function SquadHandler( array<entity> guys )
{
	// Not all maps have assaultpoints / have weird assault points ( looking at you ac )
	// So we use enemies with a large radius
	array< entity > points = GetNPCArrayOfEnemies( guys[0].GetTeam() )
	
	if ( points.len()  == 0 )
		return
	
	vector point
	point = points[ RandomInt( points.len() ) ].GetOrigin()
	
	array<entity> players = GetPlayerArrayOfEnemies( guys[0].GetTeam() )
	
	// Setup AI
	foreach ( guy in guys )
	{
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guy.AssaultPoint( point )
		guy.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
		
		// show on enemy radar
		foreach ( player in players )
			guy.Minimap_AlwaysShow( 0, player )
		
		
		//thread AITdm_CleanupBoredNPCThread( guy )
	}
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		foreach ( guy in guys )
		{
			// Check if alive
			if ( !IsAlive( guy ) )
			{
				guys.removebyvalue( guy )
				continue
			}
			// Stop func if our squad has been killed off
			if ( guys.len() == 0 )
				return
			
			// Get point and send guy to it
			points = GetNPCArrayOfEnemies( guy.GetTeam() )
			if ( points.len() == 0 )
				continue
				
			point = points[ RandomInt( points.len() ) ].GetOrigin()
			
			guy.AssaultPoint( point )
		}
		wait RandomFloatRange(5.0,15.0)
	}
}

void function TitanHandler( entity titan )
{
	array< entity > points = GetNPCArrayOfEnemies( titan.GetTeam() )
	
	if ( points.len()  == 0 )
		return
	
	vector point
	point = points[ RandomInt( points.len() ) ].GetOrigin()
	
	array<entity> players = GetPlayerArrayOfEnemies( titan.GetTeam() )
	
	// Setup AI
	titan.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	titan.AssaultPoint( point )
	titan.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	
	// show on enemy radar
	foreach ( player in players )
		titan.Minimap_AlwaysShow( 0, player )
	
	
	//thread AITdm_CleanupBoredNPCThread( guy )
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		// Check if alive
		if ( !IsAlive( titan ) )
			return
		
		// Get point and send guy to it
		points = GetNPCArrayOfEnemies( titan.GetTeam() )
		if ( points.len() == 0 )
			continue
			
		point = points[ RandomInt( points.len() ) ].GetOrigin()
		
		titan.AssaultPoint( point )
		wait RandomFloatRange(5.0,15.0)
	}
}

// Award for hacking
void function OnSpectreLeeched( entity spectre, entity player )
{
	// Set Owner so we can filter in HandleScore
	spectre.SetOwner( player )
	// Add score + update network int to trigger the "Score +n" popup
	AddTeamScore( player.GetTeam(), 1 )
	player.AddToPlayerGameStat( PGS_ASSAULT_SCORE, 1 )
	player.SetPlayerNetInt("AT_bonusPoints", player.GetPlayerGameStat( PGS_ASSAULT_SCORE ) )
}

void function ReaperHandler( entity reaper )
{
	array<entity> players = GetPlayerArrayOfEnemies( reaper.GetTeam() )
	foreach ( player in players )
		reaper.Minimap_AlwaysShow( 0, player )

	thread AITdm_CleanupBoredNPCThread( reaper )
}

void function AITdm_CleanupBoredNPCThread( entity guy )
{
	// track all ai that we spawn, ensure that they're never "bored" (i.e. stuck by themselves doing fuckall with nobody to see them) for too long
	// if they are, kill them so we can free up slots for more ai to spawn
	// we shouldn't ever kill ai if players would notice them die

	// NOTE: this partially covers up for the fact that we script ai alot less than vanilla probably does
	// vanilla probably messes more with making ai assaultpoint to fights when inactive and stuff like that, we don't do this so much

	guy.EndSignal( "OnDestroy" )
	wait 15.0 // cover spawning time from dropship/pod + before we start cleaning up

	int cleanupFailures = 0 // when this hits 2, cleanup the npc
	while ( cleanupFailures < 2 )
	{
		wait 10.0

		if ( guy.GetParent() != null )
			continue // never cleanup while spawning

		array<entity> otherGuys = GetPlayerArray()
		otherGuys.extend( GetNPCArrayOfTeam( GetOtherTeam( guy.GetTeam() ) ) )

		bool failedChecks = false

		foreach ( entity otherGuy in otherGuys )
		{
			// skip dead people
			if ( !IsAlive( otherGuy ) )
				continue

			failedChecks = false

			// don't kill if too close to anything
			if ( Distance( otherGuy.GetOrigin(), guy.GetOrigin() ) < 2000.0 )
				break

			// don't kill if ai or players can see them
			if ( otherGuy.IsPlayer() )
			{
				if ( PlayerCanSee( otherGuy, guy, true, 135 ) )
					break
			}
			else
			{
				if ( otherGuy.CanSee( guy ) )
					break
			}

			// don't kill if they can see any ai
			if ( guy.CanSee( otherGuy ) )
				break

			failedChecks = true
		}

		if ( failedChecks )
			cleanupFailures++
		else
			cleanupFailures--
	}

	print( "cleaning up bored npc: " + guy + " from team " + guy.GetTeam() )
	guy.Destroy()
}