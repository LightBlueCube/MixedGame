untyped // for AddCallback_OnUseEntity()

/* Required PlaylistVars
    roundscorelimit 9999+
    roundtimelimit 9999+
    earn_meter_pilot_multiplier 0.0
*/

// maybe ban maps like relic, crashsite and complex?
// I'm pretty not sure carring banners by a single player is a good idea, maybe banners are carried by the whole team could be better( just like apex )?

/* // Sounds to be used:
    diag_mcor_cmdr_fd_onlyPlayerIsAlive
    diag_mcor_cmdr_fd_pilotRespawn
    diag_mcor_cmdr_fd_singlePilotDown
*/

global function Modded_Gamemode_Survival_Init

const int SURVIVAL_PLAYER_TEAM                  = TEAM_MILITIA // TEAM_MILITIA
const string SURVIVAL_BURNMETER_REWARD          = "burnmeter_at_turret_weapon" // whatever you do, never give another "mp_ability_burncardweapon"

struct dropshipAnimData
{
	string idleAnim
	string idlePOVAnim
	string jumpAnim
	string jumpPOVAnim
	string attachment = "origin"
	bool hideProxy = true
	void functionref( entity ) viewConeFunc
	float yawAngle
	string firstPersonJumpOutSound // Unfortunately first person anims play for everybody, not just the person who the anim is played upon, so script needs to play the sound as opposed to a qc entry
}

struct SurvivalPlayerStruct
{
    //array<entity> carryingBanners // array<entity> for saving banner owner
    float titanEarnMeter // this mode's earnMeter is controlled manually
}

struct
{
    array<entity> respawnBeacons

    table< string, SurvivalPlayerStruct > playerSurvivalTable // it's better to use player's uid instead of the entity
    array<entity> teamCarringBanners
    array<dropshipAnimData> dropshipAnimDataList
} file

void function Modded_Gamemode_Survival_Init()
{
    // Respawn Beacon Init
    InitRespawnBeaconDropship()
    PrecacheModel( $"models/Robots/mobile_hardpoint/mobile_hardpoint.mdl" )
    RegisterSignal( "OnContinousUseStopped" )
    
    // Vanilla Mode Settings
    //SetRoundBased( true )
    SetRespawnsEnabled( false )
    //SetShouldUseRoundWinningKillReplay( true )
    //SetRoundBased( true ) //
    Riff_ForceSetEliminationMode( eEliminationMode.Pilots ) //
    Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
    Riff_ForceTitanAvailability( eTitanAvailability.Always )

    // modded settings
    // intro
	ClassicMP_SetCustomIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )
    //ClassicMP_SetCustomIntro( ClassicMP_DefaultNoIntro_Setup, ClassicMP_DefaultNoIntro_GetLength() )
    SetWaitingForPlayersMaxDuration( 30.0 ) // wait a bit longer

    // gameplay
    SetShouldPlayFactionDialogue( false ) // disable default faction dialogue, this mode needs manually controlling the dialogues
    SetBattleChatterEnableToSelf( true ) // play chatter to player themselves
    Burnmeter_SetForcedReward( SURVIVAL_BURNMETER_REWARD ) // better one: give players 3 turrets at start
    SetLateJoinRespawnEnabled( false ) // this mode use a standalone respawn method

    // custom highlight settings
    SetUseCustomHighlight( true ) 
	SetDefaultCustomHighlight( "enemy_player", "enemy_titan", "sp_friendly_hero", "sp_friendly_hero" )

    // Callbacks
    AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPilotGetLoadout )
    AddCallback_OnPlayerKilled( OnPlayerKilled )
    AddCallback_GameStateEnter( eGameState.Playing, OnGamePlaying )
}



//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnClientConnected( entity player )
{
    InitSurvivalPlayer( player )
    //TrackBannerCarrierLifeTime( player )
}

void function OnPilotGetLoadout( entity player, PilotLoadoutDef p )
{
    GivePlayerSurvivalLoadout( player )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
    DropPlayerBanner( victim, damageInfo )
}

void function OnGamePlaying()
{
    SpawnRespawnBeacons()
    //StartNPCSpawner()
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// LOADOUT FUNCTIONS /////
/////////////////////////////

const string SURVIVAL_BANNER_WEAPON             = "mp_ability_burncardweapon"

void function GivePlayerSurvivalLoadout( entity player )
{
    // player can't pull it out manually, this only for better animations
    player.GiveOffhandWeapon( SURVIVAL_BANNER_WEAPON, OFFHAND_EQUIPMENT, ["banner_collector"] )
}

/////////////////////////////////
///// LOADOUT FUNCTIONS END /////
/////////////////////////////////



///////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS /////
///////////////////////////////////////

void function InitSurvivalPlayer( entity player )
{
    SetTeam( player, SURVIVAL_PLAYER_TEAM ) // always set player to the right team

    SurvivalPlayerStruct emptyStruct
    file.playerSurvivalTable[ player.GetUID() ] <- emptyStruct
}

///////////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS END /////
///////////////////////////////////////////



///////////////////////////////////
///// PLAYER BANNER FUNCTIONS /////
///////////////////////////////////

/*
void function TrackBannerCarrierLifeTime( entity player )
{
    thread TrackBannerCarrierLifeTime_Threaded( player )
}

void function TrackBannerCarrierLifeTime_Threaded( entity player )
{
    string uid = player.GetUID()
    
    player.WaitSignal( "OnDestroy" ) // track the lifetime

    array<entity> playerBanners = GetPlayerActiveBanners( null, uid )
    // drop all the banners again
    foreach ( entity player in playerBanners )
    {
        DropPlayerBanner( player )
    }
}
*/

void function DropPlayerBanner( entity player, var damageInfo = null ) // maybe need damageinfo if player drops from edge, redirect their banners
{
    thread DropPlayerBanner_Threaded( player, damageInfo )
}

void function DropPlayerBanner_Threaded( entity player, var damageInfo )
{
    entity banner = CreatePlayerBanner( player )
}

/*
void function CollectedBannerLifeTime( entity collector, entity player )
{
    player.EndSignal( "OnDestroy" )

    table result = {}
    result.bannerDropped <- false

    OnThreadEnd(
        function(): ( collector, player, result )
        {
            if ( !IsValid( player ) ) // banner owner disconnected
            {
                if ( !result.bannerDropped && IsValid( collector ) ) // collector still alive
                    file.playerSurvivalTable[ collector.GetUID() ].carryingBanners.removebyvalue( null ) // remove the null banner
            }
        }
    )

    collector.WaitSignal( "OnDeath", "OnDestroy" ) // drop all the collected banners on death
    result.bannerDropped = true // mark as banner dropped
}
*/

const asset PLAYER_BANNER_MODEL             = $"models/weapons/ammoboxes/backpack_single.mdl"  

entity function CreatePlayerBanner( entity player )
{
    vector origin = player.GetOrigin() // + < 0,0,31 > // offset for the prop
    vector angles = < 0, player.GetAngles().y + 90, 0 > // don't want to rotate so much, yaw is enough
    int spawnFlags = 6 // SOLID_VPHYSICS

    entity banner = CreatePropDynamic( PLAYER_BANNER_MODEL, origin, angles, spawnFlags )
    banner.SetUsable()
    banner.SetUsableByGroup( "friendlies pilot" )
    banner.SetUsePrompts( "", "按下 %use% 撿起 " + player.GetPlayerName() + " 的旗幟" )
    AddCallback_OnUseEntity( banner, OnUsePlayerBanner )

    banner.SetOwner( player )
    SetTeam( banner, player.GetTeam() )
    Highlight_SetFriendlyHighlight( banner, "fw_friendly" ) // highlight it!
    thread BannerLifeTime( banner, player )

    return banner
}

function OnUsePlayerBanner( banner, collector )
{
    expect entity ( banner )
    expect entity ( collector )

    if ( IsPlayerCollectingBanner( collector ) )
        return

    entity player = banner.GetOwner()
    PlayerCollectBanner( collector, player, banner )

    //file.playerSurvivalTable[ collector.GetUID() ].carryingBanners.append( player )
    //thread CollectedBannerLifeTime( collector, player )
}

bool function IsPlayerCollectingBanner( entity player )
{
    entity weapon = player.GetActiveWeapon()
    if ( IsValid( weapon ) )
    {
        if ( weapon.GetWeaponClassName() == SURVIVAL_BANNER_WEAPON ) // the player still collecting another banner
            return true
    }

    return false
}

void function PlayerCollectBanner( entity collector, entity bannerOwner, entity banner )
{
    file.teamCarringBanners.append( bannerOwner ) // make banner's owner able to be respawned
    
    collector.SetActiveWeaponByName( SURVIVAL_BANNER_WEAPON ) // pull out burncard to play animations?
    NSSendInfoMessageToPlayer( collector, "回收了 " + bannerOwner.GetPlayerName() + " 的旗幟" )

    // disable banner usage
    Highlight_ClearFriendlyHighlight( banner )
    banner.NotSolid()
    banner.UnsetUsable()
    banner.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
}

void function BannerLifeTime( entity banner, entity owner )
{
    banner.EndSignal( "OnDestroy" )

    owner.WaitSignal( "OnDestroy" ) // if owner disconnected while banner is active, we clear the banner
    banner.Destroy()
}

array<entity> function GetTeamActiveBanners()
{
    file.teamCarringBanners.removebyvalue( null ) // clear all null banners
    
    return file.teamCarringBanners
}

void function ClearTeamBanners()
{
    file.teamCarringBanners.clear()
}

/*
array<entity> function GetPlayerActiveBanners( entity player, string uid = "" )
{
    if ( uid == "" && IsValid( player ) )
        uid = player.GetUID()
    file.playerSurvivalTable[ uid ].carryingBanners.removebyvalue( null ) // clear all null banners
    
    return file.playerSurvivalTable[ uid ].carryingBanners
}

void function ClearPlayerBanners( entity player )
{
    file.playerSurvivalTable[ player.GetUID() ].carryingBanners.clear()
}
*/

///////////////////////////////////////
///// PLAYER BANNER FUNCTIONS END /////
///////////////////////////////////////



////////////////////////////////////
///// RESPAWN BEACON FUNCTIONS /////
////////////////////////////////////

void function SpawnRespawnBeacons()
{
    foreach ( entity spawnpoint in GetEntArrayByClass_Expensive( "info_hardpoint" ) )
    {
        // use hardpoints from amped hardpoint
        if ( !spawnpoint.HasKey( "gamemode_cp" ) )
			continue
        if ( spawnpoint.kv.gamemode_cp == "0" )
            continue

        entity beacon = CreatePropDynamic( spawnpoint.GetModelName(), spawnpoint.GetOrigin(), spawnpoint.GetAngles(), 6 )
		SetTeam( beacon, SURVIVAL_PLAYER_TEAM )
        Highlight_SetFriendlyHighlight( beacon, "battery_thief" ) // how to highlight this?
        beacon.SetUsableByGroup( "friendlies pilot" )
        thread PlayAnim( beacon, "mh_inactive_idle" )

        thread RespawnBeaconThink( beacon )
        file.respawnBeacons.append( beacon )
    }
}

void function RespawnBeaconThink( entity beacon )
{
    beacon.EndSignal( "OnDestroy" )

    beacon.SetUsePrompts( "", "按住 %use% 提交旗幟卡" ) // this only needs "hold" prompts, but ttf don't have such a usage
    while ( true )
    {
        if ( GetGameState() != eGameState.Playing )
            WaitFrame()

        beacon.SetUsable()
        table result = beacon.WaitSignal( "OnPlayerUse" )
        entity user = expect entity ( result.player )
        waitthread PlayerAttemptUseRespawnBeacon( user, beacon )
    }
}

const float RESPAWN_BEACON_USE_TIME             = 5.0
const float RESPAWN_BEACON_USE_DIST2            = 64 * 64 

void function PlayerAttemptUseRespawnBeacon( entity player, entity beacon )
{
    if ( IsPlayerCollectingBanner( player ) ) // player is still collecting banners
        return

    array<entity> playersToRespawn = GetTeamActiveBanners() //GetPlayerActiveBanners( player )
    if ( playersToRespawn.len() == 0 ) // no banners to recover
    {
        SendHudMessage( player, "沒有可用旗幟", -1, -0.3, 255, 255, 0, 255, 0.2, 1.5, 0.5 )
        return
    }

    beacon.UnsetUsable()
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnContinousUseStopped" )
    int playerEHandle = player.GetEncodedEHandle()
    float endTime = Time() + RESPAWN_BEACON_USE_TIME

    OnThreadEnd
    (
        function(): ( player )
        {
            if ( IsValid( player ) )
            {
                Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_StopFirstAidProgressBar", 1 )
            }
        }
    )

    Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_StartFirstAidProgressBar", endTime, playerEHandle, playerEHandle, 1 ) // how does attemptID work?
    waitthread TrackBeaconContinuousUse( player, beacon, RESPAWN_BEACON_USE_TIME )

    // successfully reached this point
    playersToRespawn = GetTeamActiveBanners() //GetPlayerActiveBanners( player ) // update array
    vector origin = beacon.GetOrigin() + < 0, 0, 500 > // same as apex does
    vector angles = beacon.GetAngles()
    thread RespawnPlayersInDropshipAtPoint( playersToRespawn, origin, angles )
    ClearTeamBanners()
}

void function TrackBeaconContinuousUse( entity player, entity useTarget, float useTime )
{
    player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	useTarget.EndSignal( "OnDeath" )
	useTarget.EndSignal( "OnDestroy" )

	table result = {}
	result.success <- false

    int moveLockEffect = StatusEffect_AddEndless( player, eStatusEffect.move_slow, 1.0 ) // 1.0 will lock player's movement
    EmitSoundOnEntityOnlyToPlayer( player, player, "Hardpoint_Amped_ProgressBar" )

	OnThreadEnd
	(
		function() : ( player, useTarget, result, moveLockEffect )
		{
            if ( IsValid( player ) )
            {
                if ( !result.success ) // interrupted
                    player.Signal( "OnContinousUseStopped" )

                // defensive fix, restore movements
			    StatusEffect_Stop( player, moveLockEffect )

                // restore weapon usage
                player.EnableWeaponViewModel()
                player.Server_TurnOffhandWeaponsDisabledOff()

                StopSoundOnEntity( player, "Hardpoint_Amped_ProgressBar" )
            }
		}
	)

    float maxDist2 = DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) + RESPAWN_BEACON_USE_DIST2
    float startTime = Time()
	while ( Time() < startTime + useTime && player.UseButtonPressed() && !player.IsPhaseShifted() && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
	{
        // disable weapon usage
        player.DisableWeaponViewModel()
        player.Server_TurnOffhandWeaponsDisabledOn()

		if( player.ContextAction_IsActive() ) // being interupted by executions!
			return
		WaitFrame()
	}

	if ( player.UseButtonPressed() && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2  )
		result.success = true
}

void function InitRespawnBeaconDropship()
{
    dropshipAnimData dataForPlayerA
    dataForPlayerA.idleAnim           = "Classic_MP_flyin_exit_playerA_idle"
    dataForPlayerA.idlePOVAnim        = "Classic_MP_flyin_exit_povA_idle"
    dataForPlayerA.jumpAnim           = "Classic_MP_flyin_exit_playerA_jump"
    dataForPlayerA.jumpPOVAnim        = "Classic_MP_flyin_exit_povA_jump"
    dataForPlayerA.viewConeFunc       = ViewConeWide
    dataForPlayerA.yawAngle           = -18.0
    dataForPlayerA.firstPersonJumpOutSound = "commander_sequence_soldier_a_jump"

    dropshipAnimData dataForPlayerB
    dataForPlayerB.idleAnim           = "Classic_MP_flyin_exit_playerB_idle"
    dataForPlayerB.idlePOVAnim        = "Classic_MP_flyin_exit_povB_idle"
    dataForPlayerB.jumpAnim           = "Classic_MP_flyin_exit_playerB_jump"
    dataForPlayerB.jumpPOVAnim        = "Classic_MP_flyin_exit_povB_jump"
    dataForPlayerB.viewConeFunc       = ViewConeWide
    dataForPlayerB.yawAngle           = 8.0
    dataForPlayerB.firstPersonJumpOutSound = "commander_sequence_soldier_b_jump"

    dropshipAnimData dataForPlayerC
    dataForPlayerC.idleAnim           = "Classic_MP_flyin_exit_playerC_idle"
    dataForPlayerC.idlePOVAnim        = "Classic_MP_flyin_exit_povC_idle"
    dataForPlayerC.jumpAnim           = "Classic_MP_flyin_exit_playerC_jump"
    dataForPlayerC.jumpPOVAnim        = "Classic_MP_flyin_exit_povC_jump"
    dataForPlayerC.viewConeFunc       = ViewConeWide
    dataForPlayerC.yawAngle           = 8.0
    dataForPlayerC.firstPersonJumpOutSound = "commander_sequence_soldier_c_jump"

    dropshipAnimData dataForPlayerD
    dataForPlayerD.idleAnim           = "Classic_MP_flyin_exit_playerD_idle"
    dataForPlayerD.idlePOVAnim        = "Classic_MP_flyin_exit_povD_idle"
    dataForPlayerD.jumpAnim           = "Classic_MP_flyin_exit_playerD_jump"
    dataForPlayerD.jumpPOVAnim        = "Classic_MP_flyin_exit_povD_jump"
    dataForPlayerD.viewConeFunc       = ViewConeWide
    dataForPlayerD.yawAngle           = -16.0
    dataForPlayerD.firstPersonJumpOutSound = "commander_sequence_soldier_d_jump"

    file.dropshipAnimDataList = [ dataForPlayerA, dataForPlayerB, dataForPlayerC, dataForPlayerD ]
}

const string RESPAWN_DROPSHIP_TARGETNAME        = "respawn_dropship"

void function RespawnPlayersInDropshipAtPoint( array<entity> players, vector origin, vector angles )
{
	entity dropship = CreateDropship( SURVIVAL_PLAYER_TEAM, origin, angles )
	//SetSpawnOption_AISettings( dropship, "npc_dropship_hero" )
	SetTargetName( dropship, RESPAWN_DROPSHIP_TARGETNAME )
    HideName( dropship ) // no need to show health bar since it's invulnerable
	DispatchSpawn( dropship )
    dropship.SetModel( $"models/vehicle/goblin_dropship/goblin_dropship_hero.mdl" ) // force using imc dropship model
	dropship.SetInvulnerable()
	dropship.DisableHibernation()
	EmitSoundOnEntity( dropship, "goblin_imc_evac_hover" )
	//thread JetwashFX( dropship ) // stub function, no need to use

	dropship.SetOrigin( origin )
	dropship.SetAngles( angles )
	Attachment attachResult = dropship.Anim_GetAttachmentAtTime( "dropship_classic_mp_flyin", "ORIGIN", 0.0 )

	int i=0
	foreach ( entity player in players )
	{
		if ( IsValid( player ) )
		{
			thread RespawnBeacon_PutPlayerInDropship( player, dropship, i, attachResult.position )
		}
		i++
	}

	EndSignal( dropship, "OnDestroy" )

	thread PlayAnim( dropship, "dropship_colony_mcor_intro_idle", origin, angles ) // "dropship_classic_mp_flyin_idle" don't exist in ttf2
	dropship.MakeInvisible()
	waitthread __WarpInEffectShared( attachResult.position, attachResult.angle, "dropship_warpin", 0.0 )
	dropship.MakeVisible()
	waitthread PlayAnim( dropship, "dropship_classic_mp_flyin", origin, angles )
	dropship.Destroy()
}

void function RespawnBeacon_PutPlayerInDropship( entity player, entity ship, int pos, vector teleportOrigin )
{
	ship.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	dropshipAnimData animData = file.dropshipAnimDataList[ pos ]

	FirstPersonSequenceStruct idleAnimSequence
	idleAnimSequence.firstPersonAnim = animData.idlePOVAnim
	idleAnimSequence.thirdPersonAnim = animData.idleAnim
	idleAnimSequence.viewConeFunction = ViewConeFree
	idleAnimSequence.attachment = animData.attachment
	idleAnimSequence.hideProxy = animData.hideProxy

	FirstPersonSequenceStruct jumpAnimSequence
	jumpAnimSequence.firstPersonAnim = animData.jumpPOVAnim
	jumpAnimSequence.thirdPersonAnim = animData.jumpAnim
	jumpAnimSequence.viewConeFunction = ViewConeTight
	jumpAnimSequence.attachment = animData.attachment
	jumpAnimSequence.hideProxy = animData.hideProxy

	// player.Signal( "StopPostDeathLogic" )
	AddCinematicFlag( player, CE_FLAG_INTRO )
	AddCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
	//AddCinematicFlag( player, CE_FLAG_EMBARK ) // DoF, annoying

	entity dummyEnt = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" ) // TODO: use generic model.  Can't use player settings here since they could be a spectator
	float idleTime = dummyEnt.GetSequenceDuration( animData.idleAnim )
	float jumpTime = dummyEnt.GetSequenceDuration( animData.jumpAnim )
	float totalTime = idleTime + jumpTime

	dummyEnt.Destroy()

	//player.StartObserverMode( OBS_MODE_CHASE )
	//player.SetObserverTarget( ship )
    // ttf doesn't support spectating a dropship
    entity camera = CreateEntity( "point_viewcontrol" )
	camera.SetParent( ship, "Origin" )
    camera.SetAngles( < 45, -90, 0 > ) // facing the dropship
    camera.SetOrigin( < 0, 1000, 1000 > ) // offset
    camera.kv.spawnflags = 56
	DispatchSpawn( camera )
	player.SetViewEntity( camera, true )

	ScreenFadeFromBlack( player, 1.0, 1.0 )

	table<string,bool> e
	e[ "clearDof" ] <- true
	e[ "didHolsterAndDisableWeapons" ] <- false

	OnThreadEnd(
		function () : ( player, e, camera )
		{
			if ( IsValid( player ) )
			{
				RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
				RemoveCinematicFlag( player, CE_FLAG_INTRO )

				if ( e[ "clearDof" ] )
                {
					RemoveCinematicFlag( player, CE_FLAG_EMBARK )
                    player.ClearViewEntity()
                }

				if ( e[ "didHolsterAndDisableWeapons" ] )
					DeployAndEnableWeapons( player )

				player.ClearParent()
				ClearPlayerAnimViewEntity( player )
				player.ClearInvulnerable()
			}

            if ( IsValid( camera ) )
                camera.Destroy()
		}
	)

	//waitthread FirstPersonSequence( idleAnimSequence, player, ship )
	wait idleTime

	player.StopObserverMode()
    //player.ClearViewEntity()
	ClearPlayerEliminated( player )
	if ( !IsAlive( player ) )
    {
        RespawnAsPilot( player )
		//DecideRespawnPlayer( player ) // this is a stub in northstar
    }
	player.SetOrigin( ship.GetOrigin() )

	thread FadePlayerView( player, 0.1, e )
	HolsterAndDisableWeapons( player )
	e[ "didHolsterAndDisableWeapons" ] <- true
	player.SetInvulnerable()
	EmitSoundOnEntityOnlyToPlayer( player, player, animData.firstPersonJumpOutSound )
	waitthread FirstPersonSequence( jumpAnimSequence, player, ship )
	FallTempAirControl( player )

	//PlayBattleChatterLineToSpeakerAndTeam( player, "bc_returnFromRespawn" )
}

void function FadePlayerView( entity player, float duration, table<string,bool> e )
{
	player.EndSignal( "OnDeath" )
	wait duration
	RemoveCinematicFlag( player, CE_FLAG_EMBARK )
	e[ "clearDof" ] = false
	ScreenFadeFromBlack( player, 1.0, 1.0 )
}

const float FALL_AIR_CONTROL_ACCELERATION       = 800
const float FALL_AIR_CONTROL_SPEED              = 1000
const float FALL_AIR_CONTROL_DURATION           = 0.5

void function FallTempAirControl( entity player )
{
    thread FallTempAirControl_Threaded( player )
}

void function FallTempAirControl_Threaded( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

    table saved = {}
    saved.airAccel <- float( player.kv.airAcceleration )
    saved.airSpeed <- float( player.kv.airSpeed )

    OnThreadEnd(
        function(): ( player, saved )
        {
            if ( IsValid( player ) )
            {
                player.kv.airAcceleration = saved.airAccel
                player.kv.airSpeed = saved.airSpeed
            }
        }
    )
    
    player.kv.airAcceleration = FALL_AIR_CONTROL_ACCELERATION
    player.kv.airSpeed = FALL_AIR_CONTROL_SPEED
    
    wait FALL_AIR_CONTROL_DURATION
}

////////////////////////////////////////
///// RESPAWN BEACON FUNCTIONS END /////
////////////////////////////////////////



/////////////////////////////////
///// NPC SPAWNER FUNCTIONS /////
/////////////////////////////////



/////////////////////////////////////
///// NPC SPAWNER FUNCTIONS END /////
/////////////////////////////////////