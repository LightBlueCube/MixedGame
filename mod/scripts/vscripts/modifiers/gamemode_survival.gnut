untyped // for GiveExtraWeaponMod()

/* Required PlaylistVars
    scorelimit 9999+
    earn_meter_pilot_multiplier 0.0
*/

// maybe ban maps like relic, crashsite and complex?
// I'm pretty not sure carring banners by a single player is a good idea, maybe banners are carried by the whole team could be better( just like apex )?

/* // Sounds to be used:
    diag_mcor_cmdr_fd_onlyPlayerIsAlive
    diag_mcor_cmdr_fd_pilotRespawn
    diag_mcor_cmdr_fd_singlePilotDown
*/

global function Modded_Gamemode_Survival_Init


const int SURVIVAL_TOTAL_ENEMY_AMOUNT			= 660

const int SURVIVAL_PLAYER_TEAM                  = TEAM_MILITIA // TEAM_MILITIA
const int SURVIVAL_NPC_TEAM						= TEAM_IMC

const string SURVIVAL_BURNMETER_REWARD          = "burnmeter_at_turret_weapon" // whatever you do, never give another "mp_ability_burncardweapon"
const int SURVIVAL_BOOST_COUNT 					= 2

struct SurvivalPlayerStruct
{
    float titanEarnMeter // this mode's earnMeter is controlled manually
}

struct
{
	array<entity> beaconTempModels
    table< string, SurvivalPlayerStruct > playerSurvivalTable // it's better to use player's uid instead of the entity

	bool waveStarted = false
	array<string> respawnedPlayerUIDs // saved for respawning players
} file

void function Modded_Gamemode_Survival_Init()
{
	// Initialize
	RegisterSignal( "SurvivalWaveStart" )

    // Vanilla Mode Settings
    Riff_ForceBoostAvailability( eBoostAvailability.Disabled ) // player will only have certain amount of boosts
    //Riff_ForceTitanAvailability( eTitanAvailability.Never ) // titan meter is controlled by server

	AiGameModes_SetGruntWeapons( [ "mp_weapon_rspn101", "mp_weapon_dmr", "mp_weapon_r97", "mp_weapon_lmg" ] )
	AiGameModes_SetSpectreWeapons( [ "mp_weapon_hemlok_smg", "mp_weapon_doubletake", "mp_weapon_mastiff" ] )

	ScoreEvent_SetupEarnMeterValuesForMixedModes()

    // modded settings
	// rodeo
	ClassicRodeo_SetEnabled( true )

    // intro
	ClassicMP_SetCustomIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )
    SetGamemodeAnnouncementEnabled( false ) // so we can do custom announcement!
	//ClassicMP_SetCustomIntro( ClassicMP_DefaultNoIntro_Setup, ClassicMP_DefaultNoIntro_GetLength() )
    SetWaitingForPlayersMaxDuration( 30.0 ) // wait a bit longer
    ClassicMP_ForceDisableEpilogue( true )

    // gameplay
	SetLateJoinRespawnEnabled( false ) // manually do the respawning
    SetShouldPlayFactionDialogue( false ) // disable default faction dialogue, this mode needs manually controlling the dialogues
    SetBattleChatterEnableToSelf( true ) // play chatter to player themselves
    Burnmeter_SetForcedReward( SURVIVAL_BURNMETER_REWARD ) // better one: give players 3 turrets at start
    //SetLateJoinRespawnEnabled( false ) // this mode use a standalone respawn method

	// this also needs to disable the cloak and a-wall weapons in loadout functions
	SetShouldFUCKOFFCLOAK( true )
	SetShouldFUCKOFFAWALL( true )

    // custom highlight settings
    SetUseCustomHighlight( true ) 
	SetDefaultCustomHighlight( "enemy_player", "enemy_titan", "sp_friendly_hero", "sp_friendly_hero" )

    // Callbacks
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
    AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerKilled( OnPlayerKilled )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPilotGetLoadout )
    AddCallback_GameStateEnter( eGameState.Prematch, OnGamePrematch )
    AddCallback_GameStateEnter( eGameState.Playing, OnGamePlaying )
	AddCallback_GameStateEnter( eGameState.Epilogue, OnGameEpilogue )

	// modded callbacks
	AddCallback_OnPlayerRespawnBannerCollected( OnBannerCollected )
	AddCallback_OnPlayerActivateRespawnBeacon( OnBeaconActivated )

    // TEMP SCOREBOARD
	AddCallback_OnTouchHealthKit( "item_flag", OnFlagCollected )
	// TEMP PLAYLIST
    AddCallback_GameStateEnter( eGameState.Postmatch, ForceChangeMapAfterGame )
}



//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnPlayerClassChanged( entity player )
{
    UpdateSurvivalPlayerClass( player )
}

void function OnClientConnected( entity player )
{
    InitSurvivalPlayer( player )
}

void function OnPlayerRespawned( entity player )
{
	SurvivalPlayerMarkAsRespawned( player )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	SendChatMessageForPlayerKilled( victim, damageInfo )
}

void function OnPilotGetLoadout( entity player, PilotLoadoutDef p )
{
    GivePlayerSurvivalLoadout( player )
}

void function OnGamePrematch()
{
	SurvivalNPCSettings()
	SurvivalTurretSettings()
}

void function OnGamePlaying()
{
	SpawnBeaconTempModels()
    StartNPCSpawner()
	InitSurvivalEnemyScore()
	StartingGivePlayersSurvivalBoost()
	SurvivalTimerThink()
	InitSurvivalRespawnShipPoints()

	// TEMP, this is required for showing the scoreboard!
	SpawnFakeFlagCarrier()
}

void function OnGameEpilogue()
{

}

void function OnBannerCollected( entity collector, entity bannerOwner )
{
	SendChatMessageForBannerCollection( collector, bannerOwner )
}

void function OnBeaconActivated( entity activator, array<entity> playersToRespawn )
{
	AddScoreForBeaconActivation( activator, playersToRespawn )
	SendChatMessageForBeaconActivation( activator )
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// LOADOUT FUNCTIONS /////
/////////////////////////////

const int SURVIVAL_PLAYER_HEALTH = 100

void function UpdateSurvivalPlayerClass( entity player )
{
    if ( IsAlive( player ) )
    {
        player.SetMaxHealth( SURVIVAL_PLAYER_HEALTH )
        player.SetHealth( SURVIVAL_PLAYER_HEALTH )
    }
}

const array<string> SURVIVAL_DISABLED_TACTICALS =
[
	"mp_ability_cloak",
	"mp_weapon_deployable_cover"
]

const string SURVIVAL_REPLACEMENT_TACTICAL = "mp_ability_grapple"

void function GivePlayerSurvivalLoadout( entity player )
{
	entity tactical = player.GetOffhandWeapon( OFFHAND_SPECIAL )
	if ( IsValid( tactical ) )
	{
		string weaponName = tactical.GetWeaponClassName()
		if ( SURVIVAL_DISABLED_TACTICALS.contains( weaponName ) )
		{
			player.TakeWeaponNow( weaponName )
			player.GiveOffhandWeapon( SURVIVAL_REPLACEMENT_TACTICAL, OFFHAND_SPECIAL )
		}
	}


	//player.GiveExtraWeaponMod( "titandamage_weapon" )
    //player.GiveExtraWeaponMod( "at_unlimited_ammo" )
}

// prematch will clean up the boosts, should be in playing state
void function StartingGivePlayersSurvivalBoost()
{
	foreach ( entity player in GetPlayerArray() )
	{
		GivePlayerSurvivalBoost( player )
	}
}

void function GivePlayerSurvivalBoost( entity player )
{
	thread GivePlayerSurvivalBoost_Threaded( player )
}

void function GivePlayerSurvivalBoost_Threaded( entity player )
{
	//has to be delayed because PlayerConnect callbacks get called in wrong order
	WaitFrame()
	for ( int i = 0; i < SURVIVAL_BOOST_COUNT; i++ ) // give a certain amount of burncard
		PlayerInventory_PushInventoryItemByBurnRef( player, SURVIVAL_BURNMETER_REWARD )

	// turret settings
	DeployableTurret_SetAISettingsForPlayer_AP( player, "npc_turret_sentry_burn_card_ap_fd" )
	DeployableTurret_SetAISettingsForPlayer_AT( player, "npc_turret_sentry_burn_card_at_fd" )
}

/////////////////////////////////
///// LOADOUT FUNCTIONS END /////
/////////////////////////////////



///////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS /////
///////////////////////////////////////

void function InitSurvivalPlayer( entity player )
{
    SetTeam( player, SURVIVAL_PLAYER_TEAM ) // always set player to the right team

    SurvivalPlayerStruct emptyStruct
    file.playerSurvivalTable[ player.GetUID() ] <- emptyStruct

	// starting loadouts
	if ( GetGameState() >= eGameState.Playing ) // this is required for not crashing the server
		GivePlayerSurvivalBoost( player )

	// respawning
	thread TryRespawnNewConnectingPlayer( player )

	// notifications
	SurvivalGamemodeAnnouncement( player )
}

///////////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS END /////
///////////////////////////////////////////



/////////////////////////////
///// RESPAWN FUNCTIONS /////
/////////////////////////////

// prevent players from stuck inside a beacon, 
void function SpawnBeaconTempModels()
{
	foreach ( entity spawnpoint in GetEntArrayByClass_Expensive( "info_hardpoint" ) )
    {
        // use hardpoints from amped hardpoint
        if ( !spawnpoint.HasKey( "gamemode_cp" ) )
			continue
        if ( spawnpoint.kv.gamemode_cp == "0" )
            continue

		entity prop = CreatePropDynamic( spawnpoint.GetModelName(), spawnpoint.GetOrigin(), spawnpoint.GetAngles(), 6 )
		file.beaconTempModels.append( prop )
	}
}

void function DestroyBeaconTempModels()
{
	foreach ( entity prop in file.beaconTempModels )
	{
		if ( IsValid( prop ) )
			prop.Destroy()
	}
	file.beaconTempModels.clear()
}

void function InitSurvivalRespawnShipPoints()
{
	array<entity> spawnPoints
	foreach ( entity spawnpoint in GetEntArrayByClass_Expensive( "info_hardpoint" ) )
    {
        // use hardpoints from amped hardpoint
        if ( !spawnpoint.HasKey( "gamemode_cp" ) )
			continue
        if ( spawnpoint.kv.gamemode_cp == "0" )
            continue

		spawnPoints.append( spawnpoint )
    }

	SetDropshipRespawnPointsOverride( spawnPoints )
}

void function SurvivalPlayerMarkAsRespawned( entity player )
{
	if ( file.waveStarted )
		file.respawnedPlayerUIDs.append( player.GetUID() )
}

void function TryRespawnNewConnectingPlayer( entity player )
{
	player.EndSignal( "OnDestroy" )

	// wave started...
	//if ( file.waveStarted ) // for debugging
	if ( file.waveStarted && !file.respawnedPlayerUIDs.contains( player.GetUID() ) ) 
	{
		WaitFrame()
		RespawnAsPilot( player )
		// respawn into dropship to prevent unhappy situations from now
		RespawnInDropShip( player )
		TryGiveTitanToPlayer( player ) // enable titan usage
	}
}

void function TryGiveTitanToPlayer( entity player )
{
	if ( !player.IsTitan() && !IsValid( player.GetPetTitan() ) )
		PlayerEarnMeter_AddOwnedFrac( player, 1.0 )
}

/////////////////////////////////
///// RESPAWN FUNCTIONS END /////
/////////////////////////////////



///////////////////////////////
///// GAMESTATE FUNCTIONS /////
///////////////////////////////

const float SURVIVAL_WAVE_START_DELAY 			= 40 // for players ready up?
const float SURVIVAL_WAVE_TIME_LIMIT			= 720 // 12 min, if player can't finish the wave they will lose

void function SurvivalTimerThink()
{
	thread SurvivalTimerThink_Threaded()
}

void function SurvivalTimerThink_Threaded()
{
	PlayerEarnMeter_SetEnabled( false ) // disable earnmeter
	SetServerVar( "gameStartTime", Time() )
	SetServerVar( "gameEndTime", Time() + SURVIVAL_WAVE_START_DELAY + 0.2 ) // don't end the game!

	wait SURVIVAL_WAVE_START_DELAY

	SetServerVar( "gameEndTime", Time() + SURVIVAL_WAVE_TIME_LIMIT ) // update timer
	file.waveStarted = true // mark as wave started
	svGlobal.levelEnt.Signal( "SurvivalWaveStart" )

	SpawnRespawnBeacons() // in _respawn_beacon.gnut
	DestroyBeaconTempModels() // destroy the fake models
	SetRespawnsEnabled( false ) // disable the respawn
	Riff_ForceSetEliminationMode( eEliminationMode.Pilots ) // start elimination
	
	// start with titan
	PlayerEarnMeter_SetEnabled( true )
	foreach ( entity player in GetPlayerArray() )
	{
		if ( !IsAlive( player ) ) // defensive fix
			RespawnAsPilot( player )
			
		TryGiveTitanToPlayer( player )
		// mark existing players as respawned
		file.respawnedPlayerUIDs.append( player.GetUID() )
		// do announcement
		SurvivalWaveStartAnnouncement( player )
	}
}

///////////////////////////////////
///// GAMESTATE FUNCTIONS END /////
///////////////////////////////////



//////////////////////////////////
///// ANNOUNCEMENT FUNCTIONS /////
//////////////////////////////////

void function SurvivalGamemodeAnnouncement( entity player )
{
	thread DelayedSendGamemodeMessage( player )

	// TEMP NORIFICATION
    Chat_ServerPrivateMessage( player, "本服务器得分系统与语音未完工，目前在测试数据", false )
    Chat_ServerPrivateMessage( player, "无复活，尽可能在NPC的攻击下存活。死亡的玩家会掉落旗帜卡，拾取后对重生信标使用以进行重生", false )
}

void function DelayedSendGamemodeMessage( entity player )
{
	player.EndSignal( "OnDestroy" )

	wait 1 // better wait
	while ( IsPlayerUnableToReceiveAnnouncement( player ) )
		WaitFrame()

	NSSendAnnouncementMessageToPlayer( 
		player, 
		"生存模式", 
		"在時間結束前擊殺所有敵方NPC。通過重生信標復活友方。", 
		< 255, 255, 255 >, 
		1, 
		1 														// 1 means ANNOUNCEMENT_STYLE_QUICK
	)
}

bool function IsPlayerUnableToReceiveAnnouncement( entity player )
{
	if ( !IsAlive( player ) )
		return true
	if ( player.GetParent() != null && ( HasCinematicFlag( player, CE_FLAG_INTRO ) || HasCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING ) || HasCinematicFlag( player, CE_FLAG_WAVE_SPAWNING ) ) )
		return true

	return false
}

void function SendChatMessageForPlayerKilled( entity player, var damageInfo )
{
	if ( file.waveStarted )
		Chat_ServerBroadcast( "\x1b[38;5;160m" + "玩家 " + player.GetPlayerName() + " 已死亡，回收其旗幟卡以進行重生" + "\x1b[0m" )
}

void function SendChatMessageForBannerCollection( entity collector, entity bannerOwner )
{
	Chat_ServerBroadcast( "\x1b[38;5;76m" + collector.GetPlayerName() + " 回收了 " + bannerOwner.GetPlayerName() + " 的旗幟卡" + "\x1b[0m" )
}

void function SendChatMessageForBeaconActivation( entity activator )
{
	Chat_ServerBroadcast( "\x1b[38;5;33m" + activator.GetPlayerName() + " 激活了重生信標" + "\x1b[0m" )
}

void function SurvivalWaveStartAnnouncement( entity player )
{
	NSSendAnnouncementMessageToPlayer( 
		player, 
		"回合開始！", 
		"在時間結束前擊殺所有敵方NPC。通過重生信標復活友方。", 
		< 255, 255, 255 >, 
		1, 
		1 														// 1 means ANNOUNCEMENT_STYLE_QUICK
	)
}

//////////////////////////////////////
///// ANNOUNCEMENT FUNCTIONS END /////
//////////////////////////////////////



//////////////////////////////////
///// NPC SETTINGS FUNCTIONS /////
//////////////////////////////////

void function SurvivalNPCSettings()
{
	AddSpawnCallback( "npc_soldier", SetUpSurvivalMinion )
	AddSpawnCallback( "npc_spectre", SetUpSurvivalMinion )
}

void function SetUpSurvivalMinion( entity npc )
{
	npc.GiveWeapon( "mp_weapon_rocket_launcher" ) // give minions at weapon
}

//////////////////////////////////////
///// NPC SETTINGS FUNCTIONS END /////
//////////////////////////////////////



////////////////////////////
///// TURRET FUNCTIONS /////
////////////////////////////

void function SurvivalTurretSettings()
{
	AddSpawnCallback( "npc_turret_sentry", SetUpSurvivalTurret )
}

void function SetUpSurvivalTurret( entity npc )
{
	entity bossPlayer = npc.GetBossPlayer()
	if ( !IsValid( bossPlayer ) || bossPlayer.IsNPC() ) // for we may add turret grunts?
		return
	
	// init some settings
	npc.s.waitingForRepair <- false // for not multiplying the repair function!

	Highlight_SetOwnedHighlight( npc, "sp_friendly_hero" )
	AddEntityCallback_OnDamaged( npc, OnPlayerTurretDamaged )
	TurretWaitForBeingPickedUp( npc )
	thread TrackTurretBossPlayerLifeTime( npc, bossPlayer )
}

void function TrackTurretBossPlayerLifeTime( entity turret, entity bossPlayer )
{
	turret.EndSignal( "OnDestroy" )

	bossPlayer.WaitSignal( "OnDestroy" )
	turret.Destroy()
}

void function TurretWaitForBeingPickedUp( entity turret )
{
	turret.SetUsableByGroup( "owner pilot" )
	turret.SetUsePrompts( "#REFUND_HOLD_USE", "#REFUND_PRESS_USE" )

	AddCallback_OnUseEntity( turret, PlayerPickUpTurret )
}

function PlayerPickUpTurret( turret, player )
{
	expect entity ( turret )
	expect entity ( player )

	turret.UnsetUsable()
	DisablePlayerTurret( turret )
	turret.NotSolid()
	turret.SetOwner( null ) // disable ownership
	Highlight_ClearOwnedHighlight( turret )
	turret.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )

	string rewardRefund = GetTurretBurnmeterName( turret )
	PlayerInventory_PushInventoryItemByBurnRef( player, rewardRefund )
}

const array<string> BURNCARD_TURRET_AP_SETFILES = 
[
	"npc_turret_sentry_burn_card_ap",
	"npc_turret_sentry_burn_card_ap_fd",
	"npc_turret_sentry"
]

const array<string> BURNCARD_TURRET_AT_SETFILES = 
[
	"npc_turret_sentry_burn_card_at",
	"npc_turret_sentry_burn_card_at_fd",
	"npc_turret_sentry_plasma"
]

string function GetTurretBurnmeterName( entity turret )
{
	string aiSettings = turret.GetAISettingsName()

	if ( BURNCARD_TURRET_AP_SETFILES.contains( aiSettings ) )
		return "burnmeter_ap_turret_weapon"
	if ( BURNCARD_TURRET_AT_SETFILES.contains( aiSettings ) )
		return "burnmeter_at_turret_weapon"
	
	return SURVIVAL_BURNMETER_REWARD // default
}

// post damage can't handle most things even the "damage" will not be setting to 0
void function OnPlayerTurretDamaged( entity turret, var damageInfo )
{
	float damage = DamageInfo_GetDamage( damageInfo )
	//print( damage ) // the damage won't be setting to 0 even if the turret is disabled, so we really should use the turret.s.waitingForRepair
	if ( turret.GetHealth() <= damage ) // killshot
	{
		DamageInfo_SetDamage( damageInfo, turret.GetHealth() - 1 )
		turret.DisableTurret() // disable the turret and protects it
		//turret.SetHealth( 1 ) // not killing it!

		TurretWaitForBeingRepaired( turret )
	}
}

void function TurretWaitForBeingRepaired( entity turret )
{
	RemoveCallback_OnUseEntity( turret, PlayerPickUpTurret ) // disable the pickupable
	//RemoveCallback_OnUseEntity( turret, PlayerRepairTurret ) // defensive fix
	if ( turret.s.waitingForRepair ) // defensive fix!!
		return
	turret.s.waitingForRepair = true

	DisablePlayerTurret( turret )
	turret.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_ENEMY ) // notify the player this turret is down
	turret.UnsetUsable() // clear the "pickupable"
	turret.SetUsableByGroup( "owner pilot" )
	turret.SetUsePrompts( "#TURRET_WAKEUP_HOLD_USE", "#TURRET_WAKEUP_PRESS_USE" )

	AddCallback_OnUseEntity( turret, PlayerRepairTurret )
}

function PlayerRepairTurret( turret, player )
{
	expect entity ( turret )
	expect entity ( player )

	RemoveCallback_OnUseEntity( turret, PlayerRepairTurret )

	turret.s.waitingForRepair = false
	EnablePlayerTurret( turret )
	AddPlayerScore( player, "FDRepairTurret" ) // score event

	turret.SetHealth( turret.GetMaxHealth() )
	turret.UnsetUsable()
	turret.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_FRIENDLY ) // healthy turret highlight

	thread DelayedEnablePickUpTurret( turret )
}

const float TURRET_PICKUP_GRACE_PERIOD = 0.5 // prevent players double tapping to pick up the turret accidently
void function DelayedEnablePickUpTurret( entity turret )
{
	turret.EndSignal( "OnDestroy" )

	wait TURRET_PICKUP_GRACE_PERIOD
	TurretWaitForBeingPickedUp( turret )
}

void function DisablePlayerTurret( entity turret )
{
	turret.DisableTurret()
	HideName( turret )
	StopSoundOnEntity( turret, "Boost_Card_SentryTurret_Scanning_Loop_3P" ) // stop scanning sound
	turret.Signal( "StopTurretLaser" ) // stop turret laser, modified in _ai_turret_sentry
}

void function EnablePlayerTurret( entity turret )
{
	turret.EnableTurret()
	ShowName( turret )
	EmitSoundOnEntity( turret, "Boost_Card_SentryTurret_Scanning_Loop_3P" ) // start scanning sound
	thread SentryTurretAimLaser( turret )
}

void function RemoveCallback_OnUseEntity( entity ent, callbackFunc )
{
	local funcPos = ent.s.onUseEntityCallbacks.find( callbackFunc )
	if ( funcPos < 0 ) // can't find the func
		return
	ent.s.onUseEntityCallbacks.remove( expect int( funcPos ) )
}

////////////////////////////////
///// TURRET FUNCTIONS END /////
////////////////////////////////



///////////////////////////
///// SCORE FUNCTIONS /////
///////////////////////////

void function AddScoreForBeaconActivation( entity player, array<entity> savedPlayers )
{
	int score = savedPlayers.len()
	player.AddToPlayerGameStat( PGS_ASSAULT_SCORE, score )
}


void function InitSurvivalEnemyScore()
{
	// pilot/titan related
	ScoreEvent_SetEarnMeterValues( "KillPilot", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "EliminatePilot", 0.0, 0.05 )
	ScoreEvent_SetEarnMeterValues( "KillTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "KillAutoTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "EliminateTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "EliminateAutoTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "TitanKillTitan", 0.0, 0.15 ) // unsure
	ScoreEvent_SetEarnMeterValues( "PilotBatteryStolen", 0.0, 0.35 ) // this actually just doesn't have overdrive in vanilla even
	ScoreEvent_SetEarnMeterValues( "Headshot", 0.0, 0.05 )
	ScoreEvent_SetEarnMeterValues( "FirstStrike", 0.0, 0.05 )
	ScoreEvent_SetEarnMeterValues( "PilotBatteryApplied", 0.0, 0.35 )

	// ai
	ScoreEvent_SetEarnMeterValues( "KillGrunt", 0.02, 0.02, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSpectre", 0.02, 0.02, 0.5 )
	ScoreEvent_SetEarnMeterValues( "LeechSpectre", 0.02, 0.02 )
	ScoreEvent_SetEarnMeterValues( "KillStalker", 0.02, 0.02, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSuperSpectre", 0.0, 0.1 )



	AddTeamScore( SURVIVAL_NPC_TEAM, SURVIVAL_TOTAL_ENEMY_AMOUNT ) // starting amount!

	AddDeathCallback( "npc_soldier", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_spectre", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_stalker", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_super_spectre", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_titan", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_pilot_elite", SurvivalEnemyNPCKilled )
}

const int GRUNT_SCORE_AMOUNT 			= 1
const int SPECTRE_SCORE_AMOUNT 			= 1
const int STALKER_SCORE_AMOUNT 			= 1
const int REAPER_SCORE_AMOUNT 			= 3
const int TITAN_SCORE_AMOUNT			= 10
const int PILOT_SCORE_AMOUNT			= 5

void function SurvivalEnemyNPCKilled( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( !IsValid( attacker ) )
		return
	if( !attacker.IsPlayer() && !attacker.IsNPC() )
		return
	if( attacker.GetTeam() != SURVIVAL_PLAYER_TEAM )
		return

	if ( attacker == victim ) // suicide!
		return

	entity player
	if ( attacker.IsPlayer() )
		player = attacker
	// if it's a npc with bossplayer/owner...
	else if ( attacker.IsNPC() )
	{
		// reassign attacker
		if ( IsValid( attacker.GetBossPlayer() ) )
			player = attacker.GetBossPlayer()
		if ( IsValid( attacker.GetOwner() ) )
			player = attacker.GetOwner()
	}

	if ( !IsValid( player ) )
		return

	string className = victim.GetClassName()
	int scoreToRemove = 0
	string scoreEvent = "" // for npcs can't handle by OnNPCKilled(), do a extra score event

	if ( className == "npc_pilot_elite" )
	{
		scoreToRemove = PILOT_SCORE_AMOUNT
		scoreEvent = "EliminatePilot"
	}

	if ( className == "npc_soldier" )
		scoreToRemove = GRUNT_SCORE_AMOUNT

	if ( className == "npc_spectre" )
		scoreToRemove = SPECTRE_SCORE_AMOUNT

	if ( className == "npc_stalker" )
		scoreToRemove = STALKER_SCORE_AMOUNT

	if ( className == "npc_super_spectre" )
		scoreToRemove = REAPER_SCORE_AMOUNT

	// Player ejecting triggers this without the extra check
	if ( victim.IsTitan() && victim.GetBossPlayer() != player )
	{
		if ( TitanHasNpcPilot( victim ) ) // pilot was killed without ejecting
		{
			scoreToRemove = TITAN_SCORE_AMOUNT + PILOT_SCORE_AMOUNT
			scoreEvent = "EliminatePilot"
		}
		else // ejected or auto titan
			scoreToRemove = TITAN_SCORE_AMOUNT
	}

	if ( scoreEvent != "" )
		AddPlayerScore( player, scoreEvent, victim )

	if ( scoreToRemove > 0 )
	{
		player.AddToPlayerGameStat( PGS_KILLS, scoreToRemove )
		
		int scoreLeft = GameRules_GetTeamScore( SURVIVAL_NPC_TEAM )
		bool winningKill = ( scoreLeft - scoreToRemove <= 0 )

		if ( winningKill )
		{
			SurvivalTeamWinsTheGame()
			return
		}

		AddTeamScore( SURVIVAL_NPC_TEAM, -scoreToRemove ) // discard the npc team's score
	}
}

void function SurvivalTeamWinsTheGame()
{
	Riff_ForceSetEliminationMode( eEliminationMode.Default ) // disable elimination
	SetRespawnsEnabled( true ) 

	ClassicMP_ForceDisableEpilogue( false ) // re-enable epilogue for players to have fun
	ClassicMP_SetEpilogue( SurvivalEvacEpilogue ) // custom epilogue!

	GameRules_SetTeamScore( SURVIVAL_NPC_TEAM, 0 )
	AddTeamScore( SURVIVAL_PLAYER_TEAM, 1 ) // at least make player have the winning hint?

	SetWinner( SURVIVAL_PLAYER_TEAM )
}

///////////////////////////////
///// SCORE FUNCTIONS END /////
///////////////////////////////



//////////////////////////
///// EVAC FUNCTIONS /////
//////////////////////////

const float EVAC_INITIAL_WAIT = 5.0
const float EVAC_ARRIVAL_TIME = 40.0
const float EVAC_WAIT_TIME = 18.0

// celebrating the winning!
void function SurvivalEvacEpilogue()
{
	thread Evac( SURVIVAL_PLAYER_TEAM, EVAC_INITIAL_WAIT, EVAC_ARRIVAL_TIME, EVAC_WAIT_TIME, EvacEpiloguePlayerCanBoard, EvacEpilogueShouldLeaveEarly, EvacEpilogueCompleted )
}

bool function EvacEpiloguePlayerCanBoard( entity dropship, entity player )
{
	// can't board a dropship on a different team
	if ( dropship.GetTeam() != player.GetTeam() )
		return false
	
	// check if there are any free slots on the dropship, if there are then they can board
	foreach ( entity player in dropship.s.evacSlots )
		if ( !IsValid( player ) )
			return true
	
	// no empty slots
	return false
}

bool function EvacEpilogueShouldLeaveEarly( entity dropship )
{
	int numEvacing
	foreach ( entity player in dropship.s.evacSlots )
		if ( IsValid( player ) )
			numEvacing++

	return GetPlayerArrayOfTeam( dropship.GetTeam() ).len() == numEvacing || numEvacing == dropship.s.evacSlots.len()
}

void function EvacEpilogueCompleted( entity dropship )
{
	wait 5.0
	
	foreach ( entity player in GetPlayerArray() )
		ScreenFadeToBlackForever( player, 2.0 )
	
	wait 2.0
	if( GetGameState() != eGameState.Postmatch )
		SetGameState( eGameState.Postmatch )
}

//////////////////////////////
///// EVAC FUNCTIONS END /////
//////////////////////////////



///////////////////////////////
///// SCORE FUNCTIONS END /////
///////////////////////////////

void function StartNPCSpawner()
{
    thread Spawner( SURVIVAL_NPC_TEAM )
    thread SpawnerExtend( SURVIVAL_NPC_TEAM )
}

const int SQUADS_MAX_COUNT = 5
const int REAPERS_MAX_COUNT = 4
const int TITANS_MAX_COUNT = 4

// Populates the match
void function Spawner( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )
	svGlobal.levelEnt.WaitSignal( "SurvivalWaveStart" ) // wait for real start

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			//Escalate( team )

			// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
			array<entity> npcs = GetNPCArrayOfTeam( team )
			int count = npcs.len()
			int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()

			// REAPERS
            array< entity > points = SpawnPoints_GetDropPod()
            if ( reaperCount < REAPERS_MAX_COUNT )
            {
                entity node = points[ GetSpawnPointIndex( points, team ) ]
                waitthread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
            }

			// NORMAL SPAWNS
			if ( count < SQUADS_MAX_COUNT * 4 - 2 )
			{
                array<string> podEntities = ["npc_soldier", "npc_stalker", "npc_spectre"] // hardcoded
				string ent = podEntities[ RandomInt( podEntities.len() ) ]

				array< entity > points = GetZiplineDropshipSpawns()

				// Prefer dropship when spawning grunts
				if ( ent == "npc_soldier" && points.len() / 4 > 0 ) // must have more than 4 points
				{
					if ( RandomInt( points.len() / 4 ) )
					{
						entity node = points[ GetSpawnPointIndex( points, team ) ]
						waitthread AiGameModes_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, 4, SquadHandler )
						continue
					}
				}

				points = SpawnPoints_GetDropPod()
				entity node = points[ GetSpawnPointIndex( points, team ) ]
				thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent, SquadHandler )
			}
		}
		else
			break
		WaitFrame()
	}
}

// tells infantry where to go
// In vanilla there seem to be preset paths ai follow to get to the other teams vone and capture it
// AI can also flee deeper into their zone suggesting someone spent way too much time on this
void function SquadHandler( array<entity> guys )
{
	// Not all maps have assaultpoints / have weird assault points ( looking at you ac )
	// So we use enemies with a large radius
	array< entity > points = GetNPCArrayOfEnemies( guys[0].GetTeam() )
	
	if ( points.len()  == 0 )
		return
	
	vector point
	point = points[ RandomInt( points.len() ) ].GetOrigin()
	
	array<entity> players = GetPlayerArrayOfEnemies( guys[0].GetTeam() )
	
	// Setup AI
	foreach ( guy in guys )
	{
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guy.AssaultPoint( point )
		guy.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
		
		// show on enemy radar
		foreach ( player in players )
			guy.Minimap_AlwaysShow( 0, player )
		
		
		thread CleanupBoredNPCThread( guy )
	}
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		foreach ( guy in guys )
		{
			// Check if alive
			if ( !IsAlive( guy ) )
			{
				guys.removebyvalue( guy )
				continue
			}
			// Stop func if our squad has been killed off
			if ( guys.len() == 0 )
				return
			
			// Get point and send guy to it
			points = GetNPCArrayOfEnemies( guy.GetTeam() )
			if ( points.len() == 0 )
				continue
				
			point = points[ RandomInt( points.len() ) ].GetOrigin()
			
			guy.AssaultPoint( point )
		}
		wait RandomFloatRange(5.0,15.0)
	}
}

void function ReaperHandler( entity reaper )
{
	array<entity> players = GetPlayerArrayOfEnemies( reaper.GetTeam() )
	foreach ( player in players )
		reaper.Minimap_AlwaysShow( 0, player )

	thread CleanupBoredNPCThread( reaper )
}

void function CleanupBoredNPCThread( entity guy )
{
	// track all ai that we spawn, ensure that they're never "bored" (i.e. stuck by themselves doing fuckall with nobody to see them) for too long
	// if they are, kill them so we can free up slots for more ai to spawn
	// we shouldn't ever kill ai if players would notice them die

	// NOTE: this partially covers up for the fact that we script ai alot less than vanilla probably does
	// vanilla probably messes more with making ai assaultpoint to fights when inactive and stuff like that, we don't do this so much

	guy.EndSignal( "OnDestroy" )
	wait 15.0 // cover spawning time from dropship/pod + before we start cleaning up

	int cleanupFailures = 0 // when this hits 2, cleanup the npc
	while ( cleanupFailures < 2 )
	{
		wait 10.0

		if ( guy.GetParent() != null )
			continue // never cleanup while spawning

		array<entity> otherGuys = GetPlayerArray()
		otherGuys.extend( GetNPCArrayOfTeam( GetOtherTeam( guy.GetTeam() ) ) )

		bool failedChecks = false

		foreach ( entity otherGuy in otherGuys )
		{
			// skip dead people
			if ( !IsAlive( otherGuy ) )
				continue

			failedChecks = false

			// don't kill if too close to anything
			if ( Distance( otherGuy.GetOrigin(), guy.GetOrigin() ) < 2000.0 )
				break

			// don't kill if ai or players can see them
			if ( otherGuy.IsPlayer() )
			{
				if ( PlayerCanSee( otherGuy, guy, true, 135 ) )
					break
			}
			else
			{
				if ( otherGuy.CanSee( guy ) )
					break
			}

			// don't kill if they can see any ai
			if ( guy.CanSee( otherGuy ) )
				break

			failedChecks = true
		}

		if ( failedChecks )
			cleanupFailures++
		else
			cleanupFailures--
	}

	print( "cleaning up bored npc: " + guy + " from team " + guy.GetTeam() )
	guy.Destroy()
}

void function SpawnerExtend( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )
	svGlobal.levelEnt.WaitSignal( "SurvivalWaveStart" ) // wait for real start

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			//Escalate( team )

	        //int pilotCount = GetNPCArrayEx( "npc_pilot_elite", team, -1, <0,0,0>, -1 ).len() + GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()
			int titanCount = GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()

			// TITANS
			// not sure will these points collide with player's points
            if ( titanCount < TITANS_MAX_COUNT )
            {
                entity node = GetNPCTitanSpawnPoint( team )
                //entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team, TitanHandler )
                if ( RandomInt( 10 ) == 0 ) // BT has 10% chance to spawn
                    waitthread ExtraSpawner_SpawnBTWithCooper( node.GetOrigin(), node.GetAngles(), team )
                else // use a different function to prevent pilots behaves silly
                    waitthread ExtraSpawner_SpawnTitanWithPilot( node.GetOrigin(), node.GetAngles(), team )
            }
		}
		else
			break
		WaitFrame()
	}
}

int function GetSpawnPointIndex( array< entity > points, int team )
{
	entity zone = DecideSpawnZone_Generic( points, team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( points.len() )

			if ( Distance2D( points[ index ].GetOrigin(), zone.GetOrigin() ) < 6000 )
				return index
		}
	}

	return RandomInt( points.len() )
}

const float NPC_TITAN_POINT_SAFE_TIME = 10.0 // if the spawnpoint's lastUsedTime is less than this, we don't use it

entity function GetNPCTitanSpawnPoint( int team )
{
	array<entity> spawnPoints
	spawnPoints.extend( SpawnPoints_GetTitan() )
	spawnPoints.extend( SpawnPoints_GetTitanStart( TEAM_IMC ) )
	spawnPoints.extend( SpawnPoints_GetTitanStart( TEAM_MILITIA ) )

	entity zone = DecideSpawnZone_Generic( spawnPoints, team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( spawnPoints.len() )
			entity point = spawnPoints[ index ]

			if ( Distance2D( point.GetOrigin(), zone.GetOrigin() ) < 6000 )
			{
				var usedTime = point.s.lastUsedTime
				if ( usedTime + NPC_TITAN_POINT_SAFE_TIME < Time() )
				{
					point.s.lastUsedTime = Time() // mark as used
					return point
				}
			}
		}
	}

	return spawnPoints[ RandomInt( spawnPoints.len() ) ]
}

/////////////////////////////////////
///// NPC SPAWNER FUNCTIONS END /////
/////////////////////////////////////



//////////////////////////
///// TEMP FUNCTIONS /////
//////////////////////////

void function SpawnFakeFlagCarrier()
{
	entity flag = CreateEntity( "item_flag" )
	flag.SetValueForModelKey( CTF_FLAG_MODEL )
	flag.MarkAsNonMovingAttachment()
	DispatchSpawn( flag )
	flag.SetModel( CTF_FLAG_MODEL )
	flag.SetOrigin( < 0, 0, 10000 > ) // never let the player pick it up
	flag.SetVelocity( < 0, 0, 0 > )
	SetTeam( flag, SURVIVAL_PLAYER_TEAM )

	SetGlobalNetEnt( "flagCarrier", flag ) // this is required for showing the scoreboard!
}

bool function OnFlagCollected( entity player, entity flag )
{
	return false // so flag ent doesn't despawn
}

const array<string> FORCED_SURVIVAL_PLAYLIST =
[
    "mp_colony02",
    "mp_drydock",
    "mp_black_water_canal",
    "mp_thaw",
    "mp_homestead",
    "mp_forwardbase_kodai",
    "mp_angel_city"
] // excluded mp_glitch, mp_relic02, mp_grave, mp_eden, mp_wargames, mp_rise, mp_complex3 and mp_crashsite3, for they have very high parts or canyons?

void function ForceChangeMapAfterGame()
{
    string nextMap = GetNextSurvivalMap()

    ServerCommand( "map " + nextMap )
}

string function GetNextSurvivalMap()
{
	string curMapName = GetMapName()

    int mapIndex = FORCED_SURVIVAL_PLAYLIST.find( GetMapName() )
    mapIndex += 1 // next map index
	if( mapIndex == FORCED_SURVIVAL_PLAYLIST.len() ) // reached last map?
		mapIndex = 0
	string map = FORCED_SURVIVAL_PLAYLIST[mapIndex]

    return map
}

//////////////////////////////
///// TEMP FUNCTIONS END /////
//////////////////////////////