untyped // for AddCallback_OnUseEntity()

/* Required PlaylistVars
    roundscorelimit 9999+
    roundtimelimit 9999+
    earn_meter_pilot_multiplier 0.0
*/

// maybe ban maps like relic, crashsite and complex?
// I'm pretty not sure carring banners by a single player is a good idea, maybe banners are carried by the whole team could be better( just like apex )?

/* // Sounds to be used:
    diag_mcor_cmdr_fd_onlyPlayerIsAlive
    diag_mcor_cmdr_fd_pilotRespawn
    diag_mcor_cmdr_fd_singlePilotDown
*/

global function Modded_Gamemode_Survival_Init

const int SURVIVAL_PLAYER_TEAM                  = TEAM_MILITIA // TEAM_MILITIA
const string SURVIVAL_BURNMETER_REWARD          = "burnmeter_at_turret_weapon" // whatever you do, never give another "mp_ability_burncardweapon"

struct dropshipAnimData
{
	string idleAnim
	string idlePOVAnim
	string jumpAnim
	string jumpPOVAnim
	string attachment = "origin"
	bool hideProxy = true
	void functionref( entity ) viewConeFunc
	float yawAngle
	string firstPersonJumpOutSound // Unfortunately first person anims play for everybody, not just the person who the anim is played upon, so script needs to play the sound as opposed to a qc entry
}

struct SurvivalPlayerStruct
{
    //array<entity> carryingBanners // array<entity> for saving banner owner
    float titanEarnMeter // this mode's earnMeter is controlled manually
}

struct
{
    array<entity> respawnBeacons

    table< string, SurvivalPlayerStruct > playerSurvivalTable // it's better to use player's uid instead of the entity
    array<entity> teamCarringBanners
    array<dropshipAnimData> dropshipAnimDataList
} file

void function Modded_Gamemode_Survival_Init()
{
    // Respawn Beacon Init
    InitRespawnBeaconDropship()
    PrecacheModel( $"models/Robots/mobile_hardpoint/mobile_hardpoint.mdl" )
    RegisterSignal( "OnContinousUseStopped" )
    
    // Vanilla Mode Settings, how to show score boards?
    //SetRoundBased( true )
    SetRespawnsEnabled( false )
    //SetShouldUseRoundWinningKillReplay( true )
    Riff_ForceSetEliminationMode( eEliminationMode.Pilots ) //
    //Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
    Riff_ForceTitanAvailability( eTitanAvailability.Always )
    AiGameModes_SetGruntWeapons( [ "mp_weapon_rspn101", "mp_weapon_dmr", "mp_weapon_r97", "mp_weapon_lmg" ] )
	AiGameModes_SetSpectreWeapons( [ "mp_weapon_hemlok_smg", "mp_weapon_doubletake", "mp_weapon_mastiff" ] )

    // modded settings
    // intro
	ClassicMP_SetCustomIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )
    //ClassicMP_SetCustomIntro( ClassicMP_DefaultNoIntro_Setup, ClassicMP_DefaultNoIntro_GetLength() )
    SetWaitingForPlayersMaxDuration( 30.0 ) // wait a bit longer
    ClassicMP_ForceDisableEpilogue( true )

    // gameplay
    SetShouldPlayFactionDialogue( false ) // disable default faction dialogue, this mode needs manually controlling the dialogues
    SetBattleChatterEnableToSelf( true ) // play chatter to player themselves
    Burnmeter_SetForcedReward( SURVIVAL_BURNMETER_REWARD ) // better one: give players 3 turrets at start
    //SetLateJoinRespawnEnabled( false ) // this mode use a standalone respawn method

    // custom highlight settings
    SetUseCustomHighlight( true ) 
	SetDefaultCustomHighlight( "enemy_player", "enemy_titan", "sp_friendly_hero", "sp_friendly_hero" )

    // Callbacks
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
    AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPilotGetLoadout )
    AddCallback_OnPlayerKilled( OnPlayerKilled )
    AddCallback_GameStateEnter( eGameState.Prematch, OnGamePrematch )
    AddCallback_GameStateEnter( eGameState.Playing, OnGamePlaying )

    // TEMP PLAYLIST
    AddCallback_GameStateEnter( eGameState.Postmatch, ForceChangeMapAfterGame )
}



//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnPlayerClassChanged( entity player )
{
    UpdateSurvivalPlayerClass( player )
}

void function OnClientConnected( entity player )
{
    InitSurvivalPlayer( player )
    //TrackBannerCarrierLifeTime( player )

    // TEMP NORIFICATION
    Chat_ServerPrivateMessage( player, "本服务器玩法未完工，目前在测试重生信标", false )
    Chat_ServerPrivateMessage( player, "无复活，尽可能在NPC的攻击下存活。死亡的玩家会掉落旗帜卡，拾取后对重生信标使用以进行重生", false )
}

void function OnPilotGetLoadout( entity player, PilotLoadoutDef p )
{
    GivePlayerSurvivalLoadout( player )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
    DropPlayerBanner( victim, damageInfo )
}

void function OnGamePrematch()
{
    SpawnRespawnBeacons()
}

void function OnGamePlaying()
{
    StartNPCSpawner()
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// LOADOUT FUNCTIONS /////
/////////////////////////////

const int SURVIVAL_PLAYER_HEALTH = 150

void function UpdateSurvivalPlayerClass( entity player )
{
    if ( IsAlive( player ) )
    {
        player.SetMaxHealth( SURVIVAL_PLAYER_HEALTH )
        player.SetHealth( SURVIVAL_PLAYER_HEALTH )
    }
}

const string SURVIVAL_BANNER_WEAPON             = "mp_ability_burncardweapon"

void function GivePlayerSurvivalLoadout( entity player )
{
    // player can't pull it out manually, this only for better animations
    player.GiveOffhandWeapon( SURVIVAL_BANNER_WEAPON, OFFHAND_EQUIPMENT, ["banner_collector"] )
    player.GiveExtraWeaponMod( "at_unlimited_ammo" )
}

/////////////////////////////////
///// LOADOUT FUNCTIONS END /////
/////////////////////////////////



///////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS /////
///////////////////////////////////////

void function InitSurvivalPlayer( entity player )
{
    SetTeam( player, SURVIVAL_PLAYER_TEAM ) // always set player to the right team

    SurvivalPlayerStruct emptyStruct
    file.playerSurvivalTable[ player.GetUID() ] <- emptyStruct
}

///////////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS END /////
///////////////////////////////////////////



///////////////////////////////////
///// PLAYER BANNER FUNCTIONS /////
///////////////////////////////////

/*
void function TrackBannerCarrierLifeTime( entity player )
{
    thread TrackBannerCarrierLifeTime_Threaded( player )
}

void function TrackBannerCarrierLifeTime_Threaded( entity player )
{
    string uid = player.GetUID()
    
    player.WaitSignal( "OnDestroy" ) // track the lifetime

    array<entity> playerBanners = GetPlayerActiveBanners( null, uid )
    // drop all the banners again
    foreach ( entity player in playerBanners )
    {
        DropPlayerBanner( player )
    }
}
*/

void function DropPlayerBanner( entity player, var damageInfo = null ) // maybe need damageinfo if player drops from edge, redirect their banners
{
    thread DropPlayerBanner_Threaded( player, damageInfo )
}

void function DropPlayerBanner_Threaded( entity player, var damageInfo )
{
    entity banner = CreatePlayerBanner( player )
}

/*
void function CollectedBannerLifeTime( entity collector, entity player )
{
    player.EndSignal( "OnDestroy" )

    table result = {}
    result.bannerDropped <- false

    OnThreadEnd(
        function(): ( collector, player, result )
        {
            if ( !IsValid( player ) ) // banner owner disconnected
            {
                if ( !result.bannerDropped && IsValid( collector ) ) // collector still alive
                    file.playerSurvivalTable[ collector.GetUID() ].carryingBanners.removebyvalue( null ) // remove the null banner
            }
        }
    )

    collector.WaitSignal( "OnDeath", "OnDestroy" ) // drop all the collected banners on death
    result.bannerDropped = true // mark as banner dropped
}
*/

const asset PLAYER_BANNER_MODEL             = $"models/weapons/ammoboxes/backpack_single.mdl"  

entity function CreatePlayerBanner( entity player )
{
    vector origin = player.GetOrigin() // + < 0,0,31 > // offset for the prop
    vector angles = < 0, player.GetAngles().y + 90, 0 > // don't want to rotate so much, yaw is enough
    int solidType = 6 // SOLID_VPHYSICS

    entity banner = CreatePropDynamic( PLAYER_BANNER_MODEL, origin, angles, solidType )
    banner.SetUsable()
    banner.SetUsableByGroup( "friendlies pilot" )
    banner.SetUsePrompts( "", "按下 %use% 撿起 " + player.GetPlayerName() + " 的旗幟" )
    AddCallback_OnUseEntity( banner, OnUsePlayerBanner )

    banner.SetOwner( player )
    SetTeam( banner, player.GetTeam() )
    Highlight_SetFriendlyHighlight( banner, "fw_friendly" ) // highlight it!
    thread BannerLifeTime( banner, player )

    return banner
}

function OnUsePlayerBanner( banner, collector )
{
    expect entity ( banner )
    expect entity ( collector )

    if ( IsPlayerCollectingBanner( collector ) )
        return

    entity player = banner.GetOwner()
    PlayerCollectBanner( collector, player, banner )

    //file.playerSurvivalTable[ collector.GetUID() ].carryingBanners.append( player )
    //thread CollectedBannerLifeTime( collector, player )
}

bool function IsPlayerCollectingBanner( entity player )
{
    entity weapon = player.GetActiveWeapon()
    if ( IsValid( weapon ) )
    {
        if ( weapon.GetWeaponClassName() == SURVIVAL_BANNER_WEAPON ) // the player still collecting another banner
            return true
    }

    return false
}

void function PlayerCollectBanner( entity collector, entity bannerOwner, entity banner )
{
    file.teamCarringBanners.append( bannerOwner ) // make banner's owner able to be respawned
    
    collector.SetActiveWeaponByName( SURVIVAL_BANNER_WEAPON ) // pull out burncard to play animations?
    NSSendInfoMessageToPlayer( collector, "回收了 " + bannerOwner.GetPlayerName() + " 的旗幟" )

    // disable banner usage
    Highlight_ClearFriendlyHighlight( banner )
    banner.NotSolid()
    banner.UnsetUsable()
    banner.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
}

void function BannerLifeTime( entity banner, entity owner )
{
    banner.EndSignal( "OnDestroy" )

    owner.WaitSignal( "OnDestroy" ) // if owner disconnected while banner is active, we clear the banner
    banner.Destroy()
}

array<entity> function GetTeamActiveBanners()
{
    file.teamCarringBanners.removebyvalue( null ) // clear all null banners
    
    return file.teamCarringBanners
}

void function ClearTeamBanners()
{
    file.teamCarringBanners.clear()
}

/*
array<entity> function GetPlayerActiveBanners( entity player, string uid = "" )
{
    if ( uid == "" && IsValid( player ) )
        uid = player.GetUID()
    file.playerSurvivalTable[ uid ].carryingBanners.removebyvalue( null ) // clear all null banners
    
    return file.playerSurvivalTable[ uid ].carryingBanners
}

void function ClearPlayerBanners( entity player )
{
    file.playerSurvivalTable[ player.GetUID() ].carryingBanners.clear()
}
*/

///////////////////////////////////////
///// PLAYER BANNER FUNCTIONS END /////
///////////////////////////////////////



////////////////////////////////////
///// RESPAWN BEACON FUNCTIONS /////
////////////////////////////////////

void function SpawnRespawnBeacons()
{
    foreach ( entity spawnpoint in GetEntArrayByClass_Expensive( "info_hardpoint" ) )
    {
        // use hardpoints from amped hardpoint
        if ( !spawnpoint.HasKey( "gamemode_cp" ) )
			continue
        if ( spawnpoint.kv.gamemode_cp == "0" )
            continue

        asset modelName = spawnpoint.GetModelName()
        vector origin = spawnpoint.GetOrigin()
        vector angles = spawnpoint.GetAngles()
        int solidType = 6 // SOLID_VPHYSICS
        entity beacon = CreateEntity( "prop_script" ) //CreatePropDynamic( spawnpoint.GetModelName(), spawnpoint.GetOrigin(), spawnpoint.GetAngles(), 6 )
		beacon.SetValueForModelKey( modelName )
        beacon.SetOrigin( origin )
        beacon.SetAngles( angles )
        beacon.kv.solid = solidType
        beacon.DisableHibernation() // prevent it from fading
        Highlight_SetOwnedHighlight( beacon, "friendly_ai" ) // init the highlight
        
        DispatchSpawn( beacon )

        beacon.SetModel( modelName )
        thread ResetBeaconTeamToEnableHighlight( beacon ) // pretty hacky
        //Highlight_SetFriendlyHighlight( beacon, "battery_thief" ) // how to highlight this?
        Highlight_SetNeutralHighlight( beacon, "enemy_boss_bounty" )

        beacon.SetUsableByGroup( "friendlies pilot" )
        thread PlayAnim( beacon, "mh_inactive_idle" )

        // minimap icons
        beacon.Minimap_SetCustomState( eMinimapObject_prop_script.FW_BUILDSITE_SHIELDED )
        beacon.Minimap_AlwaysShow( SURVIVAL_PLAYER_TEAM, null )
        beacon.Minimap_SetAlignUpright( true )

        thread RespawnBeaconThink( beacon ) // main mechanic function
        file.respawnBeacons.append( beacon )
    }
}

// this is really hacky, but it will work if you want the entity spawn with it's highlight
void function ResetBeaconTeamToEnableHighlight( entity beacon )
{
    beacon.EndSignal( "OnDestroy" )
    SetTeam( beacon, SURVIVAL_PLAYER_TEAM )
    wait 2
    SetTeam( beacon, TEAM_UNASSIGNED )
}

void function RespawnBeaconThink( entity beacon )
{
    beacon.EndSignal( "OnDestroy" )

    beacon.SetUsePrompts( "", "按住 %use% 提交旗幟卡" ) // this only needs "hold" prompts, but ttf don't have such a usage
    while ( true )
    {
        beacon.SetUsable()
        table result = beacon.WaitSignal( "OnPlayerUse" )
        entity user = expect entity ( result.player )
        waitthread PlayerAttemptUseRespawnBeacon( user, beacon )
    }
}

const float RESPAWN_BEACON_USE_TIME             = 5.0
const float RESPAWN_BEACON_USE_DIST2            = 64 * 64 

void function PlayerAttemptUseRespawnBeacon( entity player, entity beacon )
{
    if ( GetGameState() != eGameState.Playing )
    {
        SendHudMessage( player, "不在可用時期", -1, -0.3, 255, 255, 0, 255, 0.2, 1.5, 0.5 )
        return
    }

    if ( IsPlayerCollectingBanner( player ) ) // player is still collecting banners
        return

    array<entity> playersToRespawn = GetTeamActiveBanners() //GetPlayerActiveBanners( player )
    if ( playersToRespawn.len() == 0 ) // no banners to recover
    {
        SendHudMessage( player, "沒有可用旗幟", -1, -0.3, 255, 255, 0, 255, 0.2, 1.5, 0.5 )
        return
    }

    beacon.UnsetUsable()
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    beacon.EndSignal( "OnDestroy" )
    player.EndSignal( "OnContinousUseStopped" )
    int playerEHandle = player.GetEncodedEHandle()
    float endTime = Time() + RESPAWN_BEACON_USE_TIME

    OnThreadEnd
    (
        function(): ( player )
        {
            if ( IsValid( player ) )
            {
                Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_StopFirstAidProgressBar", 1 )
            }
        }
    )

    Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_StartFirstAidProgressBar", endTime, playerEHandle, playerEHandle, 1 ) // how does attemptID work?
    waitthread TrackBeaconContinuousUse( player, beacon, RESPAWN_BEACON_USE_TIME )

    // successfully reached this point
    RespawnBeaconActivate( beacon, player.GetTeam() )
    playersToRespawn = GetTeamActiveBanners() //GetPlayerActiveBanners( player ) // update array
    vector origin = beacon.GetOrigin()
    origin.z += float ( RandomIntRange( 500, 800 ) ) // add randomness
    vector angles = beacon.GetAngles()
    angles.y = float ( RandomInt( 360 ) ) // add randomness
    thread RespawnPlayersInDropshipAtPoint( playersToRespawn, origin, angles )
    ClearTeamBanners()
}

void function TrackBeaconContinuousUse( entity player, entity useTarget, float useTime )
{
    player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	useTarget.EndSignal( "OnDeath" )
	useTarget.EndSignal( "OnDestroy" )

	table result = {}
	result.success <- false

    int moveLockEffect = StatusEffect_AddEndless( player, eStatusEffect.move_slow, 1.0 ) // 1.0 will lock player's movement
    EmitSoundOnEntityOnlyToPlayer( player, player, "Hardpoint_Amped_ProgressBar" )

	OnThreadEnd
	(
		function() : ( player, useTarget, result, moveLockEffect )
		{
            if ( IsValid( player ) )
            {
                if ( !result.success ) // interrupted
                    player.Signal( "OnContinousUseStopped" )

                // defensive fix, restore movements
			    StatusEffect_Stop( player, moveLockEffect )

                // restore weapon usage
                player.DeployWeapon()
                player.Server_TurnOffhandWeaponsDisabledOff()

                StopSoundOnEntity( player, "Hardpoint_Amped_ProgressBar" )
            }
		}
	)

    float maxDist2 = DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) + RESPAWN_BEACON_USE_DIST2
    float startTime = Time()
	while ( Time() < startTime + useTime && player.UseButtonPressed() && !player.IsPhaseShifted() && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
	{
        // disable weapon usage
        player.HolsterWeapon()
        player.Server_TurnOffhandWeaponsDisabledOn()

		if( player.ContextAction_IsActive() ) // being interupted by executions!
			return
        //if ( GetTeamActiveBanners().len() == 0 ) // no valid banners
            //return
		WaitFrame()
	}

	if ( player.UseButtonPressed() && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2  )
		result.success = true
}

void function RespawnBeaconActivate( entity beacon, int team )
{
    thread RespawnBeaconActivate_Threaded( beacon, team )
}

const asset RESPAWN_BEACON_ACTIVATE_FX = $"P_wpn_arcTrap_start"
const asset RESPAWN_BEACON_RING_FX = $"P_arcTrap_light"
const asset RESPAWN_BEACON_INDICATOR_FX = $"P_ar_titan_droppoint"
const float RESPAWN_BEACON_ACTIVATE_TIME = 2.0 // good for animations to play

void function RespawnBeaconActivate_Threaded( entity beacon, int team )
{
    beacon.EndSignal( "OnDestroy" )
    vector origin = beacon.GetOrigin()
    vector angles = beacon.GetAngles()
    vector surfaceNormal = < 0, 0, 1 >
    SetTeam( beacon, team ) // set team for a while

    entity fxModel = CreatePropDynamic( $"models/weapons/sentry_shield/sentry_shield_proj.mdl", origin, angles )
	fxModel.Hide()

    array<entity> activeFXs
    int attachID = fxModel.LookupAttachment( "fx_center" )
    int startFxId = GetParticleSystemIndex( RESPAWN_BEACON_ACTIVATE_FX )
    activeFXs.append( StartParticleEffectOnEntity_ReturnEntity( fxModel, startFxId, FX_PATTACH_POINT_FOLLOW, attachID ) )

	int ringFxId = GetParticleSystemIndex( RESPAWN_BEACON_RING_FX )
    activeFXs.append( StartParticleEffectOnEntity_ReturnEntity( fxModel, ringFxId, FX_PATTACH_POINT_FOLLOW, attachID ) )

    int indicFxId = GetParticleSystemIndex( RESPAWN_BEACON_INDICATOR_FX )
    entity indicatorFX = StartParticleEffectInWorld_ReturnEntity( indicFxId, origin, surfaceNormal )
    EffectSetControlPointVector( indicatorFX, 1, < 128,188,255 > ) // blue
	indicatorFX.DisableHibernation()
    activeFXs.append( indicatorFX )

    EmitSoundOnEntity( beacon, "hardpoint_console_captured" )
    thread PlayAnim( beacon, "mh_inactive_2_active" ) // amped animation

    OnThreadEnd
    (
        function(): ( fxModel, activeFXs, beacon )
        {
            foreach ( entity fx in activeFXs )
            {
                if ( IsValid( fx ) )
                    EffectStop( fx )
            }

            if ( IsValid( fxModel ) )
                fxModel.Destroy()

            if ( IsValid( beacon ) )
            {
                SetTeam( beacon, TEAM_UNASSIGNED )
                thread PlayAnim( beacon, "mh_active_2_inactive" )
            }
        }
    )

    wait RESPAWN_BEACON_ACTIVATE_TIME
}

void function InitRespawnBeaconDropship()
{
    dropshipAnimData dataForPlayerA
    dataForPlayerA.idleAnim           = "Classic_MP_flyin_exit_playerA_idle"
    dataForPlayerA.idlePOVAnim        = "Classic_MP_flyin_exit_povA_idle"
    dataForPlayerA.jumpAnim           = "Classic_MP_flyin_exit_playerA_jump"
    dataForPlayerA.jumpPOVAnim        = "Classic_MP_flyin_exit_povA_jump"
    dataForPlayerA.viewConeFunc       = ViewConeWide
    dataForPlayerA.yawAngle           = -18.0
    dataForPlayerA.firstPersonJumpOutSound = "commander_sequence_soldier_a_jump"

    dropshipAnimData dataForPlayerB
    dataForPlayerB.idleAnim           = "Classic_MP_flyin_exit_playerB_idle"
    dataForPlayerB.idlePOVAnim        = "Classic_MP_flyin_exit_povB_idle"
    dataForPlayerB.jumpAnim           = "Classic_MP_flyin_exit_playerB_jump"
    dataForPlayerB.jumpPOVAnim        = "Classic_MP_flyin_exit_povB_jump"
    dataForPlayerB.viewConeFunc       = ViewConeWide
    dataForPlayerB.yawAngle           = 8.0
    dataForPlayerB.firstPersonJumpOutSound = "commander_sequence_soldier_b_jump"

    dropshipAnimData dataForPlayerC
    dataForPlayerC.idleAnim           = "Classic_MP_flyin_exit_playerC_idle"
    dataForPlayerC.idlePOVAnim        = "Classic_MP_flyin_exit_povC_idle"
    dataForPlayerC.jumpAnim           = "Classic_MP_flyin_exit_playerC_jump"
    dataForPlayerC.jumpPOVAnim        = "Classic_MP_flyin_exit_povC_jump"
    dataForPlayerC.viewConeFunc       = ViewConeWide
    dataForPlayerC.yawAngle           = 8.0
    dataForPlayerC.firstPersonJumpOutSound = "commander_sequence_soldier_c_jump"

    dropshipAnimData dataForPlayerD
    dataForPlayerD.idleAnim           = "Classic_MP_flyin_exit_playerD_idle"
    dataForPlayerD.idlePOVAnim        = "Classic_MP_flyin_exit_povD_idle"
    dataForPlayerD.jumpAnim           = "Classic_MP_flyin_exit_playerD_jump"
    dataForPlayerD.jumpPOVAnim        = "Classic_MP_flyin_exit_povD_jump"
    dataForPlayerD.viewConeFunc       = ViewConeWide
    dataForPlayerD.yawAngle           = -16.0
    dataForPlayerD.firstPersonJumpOutSound = "commander_sequence_soldier_d_jump"

    file.dropshipAnimDataList = [ dataForPlayerA, dataForPlayerB, dataForPlayerC, dataForPlayerD ]
}

const string RESPAWN_DROPSHIP_TARGETNAME        = "respawn_dropship"

void function RespawnPlayersInDropshipAtPoint( array<entity> players, vector origin, vector angles )
{
	entity dropship = CreateDropship( SURVIVAL_PLAYER_TEAM, origin, angles )
	//SetSpawnOption_AISettings( dropship, "npc_dropship_hero" )
	SetTargetName( dropship, RESPAWN_DROPSHIP_TARGETNAME )
    HideName( dropship ) // no need to show health bar since it's invulnerable
	DispatchSpawn( dropship )
    dropship.SetModel( $"models/vehicle/goblin_dropship/goblin_dropship_hero.mdl" ) // force using imc dropship model
	dropship.SetInvulnerable()
	dropship.DisableHibernation()
	EmitSoundOnEntity( dropship, "goblin_imc_evac_hover" )
	//thread JetwashFX( dropship ) // stub function, no need to use

	dropship.SetOrigin( origin )
	dropship.SetAngles( angles )
	Attachment attachResult = dropship.Anim_GetAttachmentAtTime( "dropship_classic_mp_flyin", "ORIGIN", 0.0 )

	int i=0
	foreach ( entity player in players )
	{
		if ( IsValid( player ) )
		{
			thread RespawnBeacon_PutPlayerInDropship( player, dropship, i, attachResult.position )
		}
		i++
	}

	EndSignal( dropship, "OnDestroy" )

	thread PlayAnim( dropship, "dropship_colony_mcor_intro_idle", origin, angles ) // "dropship_classic_mp_flyin_idle" don't exist in ttf2
	dropship.MakeInvisible()
	waitthread __WarpInEffectShared( attachResult.position, attachResult.angle, "dropship_warpin", 0.0 )
	dropship.MakeVisible()
	waitthread PlayAnim( dropship, "dropship_classic_mp_flyin", origin, angles )
	dropship.Destroy()
}

void function RespawnBeacon_PutPlayerInDropship( entity player, entity ship, int pos, vector teleportOrigin )
{
	ship.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	dropshipAnimData animData = file.dropshipAnimDataList[ pos ]

	FirstPersonSequenceStruct idleAnimSequence
	idleAnimSequence.firstPersonAnim = animData.idlePOVAnim
	idleAnimSequence.thirdPersonAnim = animData.idleAnim
	idleAnimSequence.viewConeFunction = ViewConeFree
	idleAnimSequence.attachment = animData.attachment
	idleAnimSequence.hideProxy = animData.hideProxy

	FirstPersonSequenceStruct jumpAnimSequence
	jumpAnimSequence.firstPersonAnim = animData.jumpPOVAnim
	jumpAnimSequence.thirdPersonAnim = animData.jumpAnim
	jumpAnimSequence.viewConeFunction = ViewConeTight
	jumpAnimSequence.attachment = animData.attachment
	jumpAnimSequence.hideProxy = animData.hideProxy

	// player.Signal( "StopPostDeathLogic" )
	AddCinematicFlag( player, CE_FLAG_INTRO )
	AddCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
	//AddCinematicFlag( player, CE_FLAG_EMBARK ) // DoF, annoying

	entity dummyEnt = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" ) // TODO: use generic model.  Can't use player settings here since they could be a spectator
	float idleTime = dummyEnt.GetSequenceDuration( animData.idleAnim )
	float jumpTime = dummyEnt.GetSequenceDuration( animData.jumpAnim )
	float totalTime = idleTime + jumpTime

	dummyEnt.Destroy()

	//player.StartObserverMode( OBS_MODE_CHASE )
	//player.SetObserverTarget( ship )
    // ttf doesn't support spectating a dropship
    entity camera = CreateEntity( "point_viewcontrol" )
	camera.SetParent( ship, "Origin" )
    camera.SetAngles( < 45, -90, 0 > ) // facing the dropship
    camera.SetOrigin( < 0, 1000, 1000 > ) // offset
    camera.kv.spawnflags = 56
	DispatchSpawn( camera )
	player.SetViewEntity( camera, true )

	ScreenFadeFromBlack( player, 1.0, 1.0 )

	table<string,bool> e
	e[ "clearDof" ] <- true
	e[ "didHolsterAndDisableWeapons" ] <- false

	OnThreadEnd(
		function () : ( player, e, camera )
		{
			if ( IsValid( player ) )
			{
				RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
				RemoveCinematicFlag( player, CE_FLAG_INTRO )

				if ( e[ "clearDof" ] )
                {
					RemoveCinematicFlag( player, CE_FLAG_EMBARK )
                    player.ClearViewEntity()
                }

				if ( e[ "didHolsterAndDisableWeapons" ] )
					DeployAndEnableWeapons( player )

				player.ClearParent()
				ClearPlayerAnimViewEntity( player )
				player.ClearInvulnerable()
			}

            if ( IsValid( camera ) )
                camera.Destroy()
		}
	)

	//waitthread FirstPersonSequence( idleAnimSequence, player, ship )
	wait idleTime

	player.StopObserverMode()
    //player.ClearViewEntity()
	ClearPlayerEliminated( player )
	if ( !IsAlive( player ) )
    {
        RespawnAsPilot( player )
		//DecideRespawnPlayer( player ) // this is a stub in northstar
    }
	player.SetOrigin( ship.GetOrigin() )

	thread FadePlayerView( player, 0.1, e )
	HolsterAndDisableWeapons( player )
	e[ "didHolsterAndDisableWeapons" ] <- true
	player.SetInvulnerable()
	EmitSoundOnEntityOnlyToPlayer( player, player, animData.firstPersonJumpOutSound )
	waitthread FirstPersonSequence( jumpAnimSequence, player, ship )
	FallTempAirControl( player )

	//PlayBattleChatterLineToSpeakerAndTeam( player, "bc_returnFromRespawn" )
}

void function FadePlayerView( entity player, float duration, table<string,bool> e )
{
	player.EndSignal( "OnDeath" )
	wait duration
	RemoveCinematicFlag( player, CE_FLAG_EMBARK )
	e[ "clearDof" ] = false
	ScreenFadeFromBlack( player, 1.0, 1.0 )
}

const float FALL_AIR_CONTROL_ACCELERATION       = 800
const float FALL_AIR_CONTROL_SPEED              = 1000
const float FALL_AIR_CONTROL_DURATION           = 0.5

void function FallTempAirControl( entity player )
{
    thread FallTempAirControl_Threaded( player )
}

void function FallTempAirControl_Threaded( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

    table saved = {}
    saved.airAccel <- float( player.kv.airAcceleration )
    saved.airSpeed <- float( player.kv.airSpeed )

    OnThreadEnd(
        function(): ( player, saved )
        {
            if ( IsValid( player ) )
            {
                player.kv.airAcceleration = saved.airAccel
                player.kv.airSpeed = saved.airSpeed
            }
        }
    )
    
    player.kv.airAcceleration = FALL_AIR_CONTROL_ACCELERATION
    player.kv.airSpeed = FALL_AIR_CONTROL_SPEED
    
    wait FALL_AIR_CONTROL_DURATION
}

////////////////////////////////////////
///// RESPAWN BEACON FUNCTIONS END /////
////////////////////////////////////////



/////////////////////////////////
///// NPC SPAWNER FUNCTIONS /////
/////////////////////////////////

void function StartNPCSpawner()
{
    thread Spawner( GetOtherTeam( SURVIVAL_PLAYER_TEAM ) )
    thread SpawnerExtend( GetOtherTeam( SURVIVAL_PLAYER_TEAM ) )
}

const int SQUADS_MAX_COUNT = 5
const int REAPERS_MAX_COUNT = 3
const int TITANS_MAX_COUNT = 3

// Populates the match
void function Spawner( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			//Escalate( team )

			// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
			array<entity> npcs = GetNPCArrayOfTeam( team )
			int count = npcs.len()
			int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()

			// REAPERS
            array< entity > points = SpawnPoints_GetDropPod()
            if ( reaperCount < REAPERS_MAX_COUNT )
            {
                entity node = points[ GetSpawnPointIndex( points, team ) ]
                waitthread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
            }

			// NORMAL SPAWNS
			if ( count < SQUADS_MAX_COUNT * 4 - 2 )
			{
                array<string> podEntities = ["npc_soldier", "npc_stalker", "npc_spectre"]
				string ent = podEntities[ RandomInt( podEntities.len() ) ]

				array< entity > points = GetZiplineDropshipSpawns()

				// Prefer dropship when spawning grunts
				if ( ent == "npc_soldier" && points.len() / 4 > 0 ) // must have more than 4 points
				{
					if ( RandomInt( points.len() / 4 ) )
					{
						entity node = points[ GetSpawnPointIndex( points, team ) ]
						waitthread AiGameModes_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, 4, SquadHandler )
						continue
					}
				}

				points = SpawnPoints_GetDropPod()
				entity node = points[ GetSpawnPointIndex( points, team ) ]
				thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent, SquadHandler )
			}
		}
		else
			break
		WaitFrame()
	}
}

// tells infantry where to go
// In vanilla there seem to be preset paths ai follow to get to the other teams vone and capture it
// AI can also flee deeper into their zone suggesting someone spent way too much time on this
void function SquadHandler( array<entity> guys )
{
	// Not all maps have assaultpoints / have weird assault points ( looking at you ac )
	// So we use enemies with a large radius
	array< entity > points = GetNPCArrayOfEnemies( guys[0].GetTeam() )
	
	if ( points.len()  == 0 )
		return
	
	vector point
	point = points[ RandomInt( points.len() ) ].GetOrigin()
	
	array<entity> players = GetPlayerArrayOfEnemies( guys[0].GetTeam() )
	
	// Setup AI
	foreach ( guy in guys )
	{
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guy.AssaultPoint( point )
		guy.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
		
		// show on enemy radar
		foreach ( player in players )
			guy.Minimap_AlwaysShow( 0, player )
		
		
		thread CleanupBoredNPCThread( guy )
	}
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		foreach ( guy in guys )
		{
			// Check if alive
			if ( !IsAlive( guy ) )
			{
				guys.removebyvalue( guy )
				continue
			}
			// Stop func if our squad has been killed off
			if ( guys.len() == 0 )
				return
			
			// Get point and send guy to it
			points = GetNPCArrayOfEnemies( guy.GetTeam() )
			if ( points.len() == 0 )
				continue
				
			point = points[ RandomInt( points.len() ) ].GetOrigin()
			
			guy.AssaultPoint( point )
		}
		wait RandomFloatRange(5.0,15.0)
	}
}

void function ReaperHandler( entity reaper )
{
	array<entity> players = GetPlayerArrayOfEnemies( reaper.GetTeam() )
	foreach ( player in players )
		reaper.Minimap_AlwaysShow( 0, player )

	thread CleanupBoredNPCThread( reaper )
}

void function CleanupBoredNPCThread( entity guy )
{
	// track all ai that we spawn, ensure that they're never "bored" (i.e. stuck by themselves doing fuckall with nobody to see them) for too long
	// if they are, kill them so we can free up slots for more ai to spawn
	// we shouldn't ever kill ai if players would notice them die

	// NOTE: this partially covers up for the fact that we script ai alot less than vanilla probably does
	// vanilla probably messes more with making ai assaultpoint to fights when inactive and stuff like that, we don't do this so much

	guy.EndSignal( "OnDestroy" )
	wait 15.0 // cover spawning time from dropship/pod + before we start cleaning up

	int cleanupFailures = 0 // when this hits 2, cleanup the npc
	while ( cleanupFailures < 2 )
	{
		wait 10.0

		if ( guy.GetParent() != null )
			continue // never cleanup while spawning

		array<entity> otherGuys = GetPlayerArray()
		otherGuys.extend( GetNPCArrayOfTeam( GetOtherTeam( guy.GetTeam() ) ) )

		bool failedChecks = false

		foreach ( entity otherGuy in otherGuys )
		{
			// skip dead people
			if ( !IsAlive( otherGuy ) )
				continue

			failedChecks = false

			// don't kill if too close to anything
			if ( Distance( otherGuy.GetOrigin(), guy.GetOrigin() ) < 2000.0 )
				break

			// don't kill if ai or players can see them
			if ( otherGuy.IsPlayer() )
			{
				if ( PlayerCanSee( otherGuy, guy, true, 135 ) )
					break
			}
			else
			{
				if ( otherGuy.CanSee( guy ) )
					break
			}

			// don't kill if they can see any ai
			if ( guy.CanSee( otherGuy ) )
				break

			failedChecks = true
		}

		if ( failedChecks )
			cleanupFailures++
		else
			cleanupFailures--
	}

	print( "cleaning up bored npc: " + guy + " from team " + guy.GetTeam() )
	guy.Destroy()
}

void function SpawnerExtend( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			//Escalate( team )

	        int pilotCount = GetNPCArrayEx( "npc_pilot_elite", team, -1, <0,0,0>, -1 ).len() + GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()

			// PILOTS
            array< entity > points = SpawnPoints_GetDropPod()
            if ( pilotCount < TITANS_MAX_COUNT )
            {
                entity node = points[ GetSpawnPointIndex( points, team ) ]
                //entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team, TitanHandler )
                if ( RandomInt( 10 ) == 0 ) // BT has 10% chance to spawn
                    waitthread ExtraSpawner_SpawnBTWithCooper( node.GetOrigin(), node.GetAngles(), team )
                else
                    waitthread ExtraSpawner_SpawnPilotCanEmbark( node.GetOrigin(), node.GetAngles(), team )
            }
		}
		else
			break
		WaitFrame()
	}
}

int function GetSpawnPointIndex( array< entity > points, int team )
{
	entity zone = DecideSpawnZone_Generic( points, team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( points.len() )

			if ( Distance2D( points[ index ].GetOrigin(), zone.GetOrigin() ) < 6000 )
				return index
		}
	}

	return RandomInt( points.len() )
}

/////////////////////////////////////
///// NPC SPAWNER FUNCTIONS END /////
/////////////////////////////////////



//////////////////////////
///// TEMP FUNCTIONS /////
//////////////////////////

const array<string> FORCED_SURVIVAL_PLAYLIST =
[
    "mp_glitch",
    "mp_colony02",
    "mp_drydock",
    "mp_black_water_canal",
    "mp_thaw",
    "mp_homestead",
    "mp_forwardbase_kodai",
    "mp_angel_city"
] // excluded mp_relic02, mp_grave, mp_eden, mp_wargames, mp_rise, mp_complex3 and mp_crashsite3, for they have very high parts or canyons?

void function ForceChangeMapAfterGame()
{
    string nextMap = GetNextSurvivalMap()

    ServerCommand( "map " + nextMap )
}

string function GetNextSurvivalMap()
{
	string curMapName = GetMapName()

    int mapIndex = FORCED_SURVIVAL_PLAYLIST.find( GetMapName() )
    mapIndex += 1 // next map index
	if( mapIndex == FORCED_SURVIVAL_PLAYLIST.len() ) // reached last map?
		mapIndex = 0
	string map = FORCED_SURVIVAL_PLAYLIST[mapIndex]

    return map
}

//////////////////////////////
///// TEMP FUNCTIONS END /////
//////////////////////////////