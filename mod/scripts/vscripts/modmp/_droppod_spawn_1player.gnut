untyped
global function DropPodSpawn1Player_Init

global function SpawnFromDroppod
global function SpawnPlayerInDropPod

struct {
	array< entity > droppods
} file

struct {
	entity intermissionCam
	array<entity> droppodSpawns

} droppod

void function DropPodSpawn1Player_Init()
{
	RegisterSignal( "PlayerDroppodImpact" ) // signal for sending info messages

	if ( GetMapName() != "mp_lobby" ) // don't run this in lobby
		AddCallback_EntitiesDidLoad( AddDroppodSpawn )
	//AddSpawnCallback( "info_spawnpoint_droppod_start", AddDroppodSpawn )
	//AddCallback_OnRoundEndCleanup( CleanupSpawningDropPods )
}

void function SpawnFromDroppod( entity player, float destructionTime = 10 )
{
	thread SpawnFromDroppod_Threaded( player, destructionTime )
}

void function SpawnFromDroppod_Threaded( entity player, float destructionTime = 10 )
{
	if ( !IsValid( player ) )
		return
	if( GetGameState() >= eGameState.Postmatch )
		return
	// can't implement it good enough
	entity spawnpoint = FindPlayerDroppodSpawnPoint( player.GetTeam() )
	SpawnPlayerInDropPod( player, spawnpoint.GetOrigin(), spawnpoint.GetAngles(), destructionTime )
}

void function CleanupSpawningDropPods()
{
	foreach ( entity pod in file.droppods )
		pod.Destroy()
	
	file.droppods.clear()
}

void function SpawnPlayerInDropPod( entity player, vector targetOrigin, vector angles, float destructionTime = -1 )
{
	if ( !IsValid( player ) )
		return

	svGlobal.levelEnt.EndSignal( "CleanUpEntitiesForRoundEnd" )

	entity pod = CreateDropPod( targetOrigin, angles )
	file.droppods.append( pod )
	
	// TODO: we need to make a door for this, CreateDropPodDoor in _droppod_fireteam is just busted for some reason tho
	
	entity camera = CreateEntity( "point_viewcontrol" )
	vector podloaction = pod.GetOrigin() + Vector( 0, 0, 3000 )
	camera.SetLocalOrigin( podloaction )
	camera.SetAngles( < 90, angles.y, 0 > )
	
	if ( !IsAlive( player ) )
		player.RespawnPlayer( null )

	if( IsValid( pod ) )
	{
		player.SetOrigin( pod.GetOrigin() )
		player.SetAngles( pod.GetAngles() )
		player.SetParent( pod )
	}

	if( IsValid( player ) )
	{
		player.FreezeControlsOnServer()
		AddCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
		player.SetViewEntity( camera, true )
	}
	
	// wait for this
	LaunchAnimDropPod( pod, "pod_testpath", targetOrigin, angles )
	
	//WaitFrame()
	if( IsValid( player ) && GetGameState() < eGameState.Postmatch )
	{
		player.ClearParent()
		player.ClearViewEntity()
		player.UnfreezeControlsOnServer()
		player.Signal( "PlayerDroppodImpact" )
		RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
		FindNearestSafeSpotAndPutEntity( player, 1 ) // defensive fix
	}

	if ( destructionTime != -1 && GamePlaying() )
	{
		wait destructionTime
		if ( IsValid( pod ) )
		{
			//pod.NotSolid() // so it won't block player's movement
			pod.Dissolve( ENTITY_DISSOLVE_NORMAL, < 0, 0, 0 >, 0 )
		
			file.droppods.remove( file.droppods.find( pod ) )
		}
		
	}
}

void function AddDroppodSpawn()
{
	// now adding more spawnpoints
	droppod.droppodSpawns.extend( SpawnPoints_GetTitan() )
	// remove titan start points, since grunt mode uses them as titan's spawn point
	//droppod.droppodSpawns.extend( SpawnPoints_GetTitanStart( TEAM_IMC ) )
	//droppod.droppodSpawns.extend( SpawnPoints_GetTitanStart( TEAM_MILITIA ) )
	droppod.droppodSpawns.extend( SpawnPoints_GetDropPod() )

	array<entity> pilotSpawns
	pilotSpawns.extend( SpawnPoints_GetPilot() )
	pilotSpawns.extend( SpawnPoints_GetPilotStart( TEAM_IMC ) )
	pilotSpawns.extend( SpawnPoints_GetPilotStart( TEAM_MILITIA ) )
	foreach ( entity point in pilotSpawns )
	{
		// if there're nothing blocked within 3000 hu we consider use it as a spawnpoint
		TraceResults roofCheck = TraceLine( point.GetOrigin(), point.GetOrigin() + < 0,0,3000 >, point, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
		// if there're also nothing blocking the door we surely use it as a spawnpoint
		TraceResults doorCheck = TraceLine( point.GetOrigin(), point.GetOrigin() + AnglesToForward( < 0,point.GetAngles().y, 0> ) * 30, point, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
		
		//print( "[DROPPOD_RESPAWN] pilot spawn point at: " + string( point.GetOrigin() ) + " roofcheck: " + string( roofCheck.hitEnt ) )
		//print( "[DROPPOD_RESPAWN] pilot spawn point at: " + string( point.GetOrigin() ) + " doorCheck: " + string( doorCheck.hitEnt ) )

		if ( !IsValid( roofCheck.hitEnt ) && !IsValid( doorCheck.hitEnt ) )
		{
			droppod.droppodSpawns.append( point )
			//print( "[DROPPOD_RESPAWN] found a valid pilot spawn point at: " + string( point.GetOrigin() ) )
		}
	}

	foreach ( entity point in droppod.droppodSpawns )
	{
		point.s.droppodLastUsedTime <- -1
		point.s.droppodLastUsedTeam <- TEAM_UNASSIGNED // for better checks?
	}
}

const float SPAWN_ZONE_SEARCH_RADIUS = 1800
const float DROPPOD_POINT_COOLDOWN = 10.0

// should use a better one
entity function FindPlayerDroppodSpawnPoint( int team )
{
	array<entity> spawnPoints = droppod.droppodSpawns
	entity zone = DecideSpawnZone_Generic( spawnPoints, team )
	
	entity chosenPoint
	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			entity point = spawnPoints[ RandomInt( spawnPoints.len() ) ]
		
			if ( Distance2D( point.GetOrigin(), zone.GetOrigin() ) < SPAWN_ZONE_SEARCH_RADIUS && point.s.droppodLastUsedTime + DROPPOD_POINT_COOLDOWN < Time() ) // smaller search
			{
				chosenPoint = point
				//print( "[DROPPOD_RESPAWN] found a point which inside spawn zone and off cooldown!" )
				break
			}
		}
	}
	
	if ( !IsValid( chosenPoint ) )
	{
		// 20 Tries to get a random point off cooldown
		for ( int i = 0; i < 20; i++ )
		{
			entity point = spawnPoints[ RandomInt( spawnPoints.len() ) ]

			if ( point.s.droppodLastUsedTime + DROPPOD_POINT_COOLDOWN < Time() )
			{
				chosenPoint = point
				//print( "[DROPPOD_RESPAWN] found a point which is off cooldown!" )
				break
			}
		}
	}

	// still have no valid point... use a completely random one
	if ( !IsValid( chosenPoint ) )
	{
		chosenPoint = spawnPoints[ RandomInt( spawnPoints.len() ) ]
		//print( "[DROPPOD_RESPAWN] can't find any valid point! now using a random one" )
	}

	chosenPoint.s.droppodLastUsedTime = Time()
	//print( "[DROPPOD_RESPAWN] current respawn point origin: " + string( chosenPoint.GetOrigin() ) )
	return chosenPoint
}