//Bleed Out Mechanic Shared by several game modes.
// WIP: Health limited incap shield( done ), Downed Fake Player
/*
WARNING BY NESSIE( fixed by Bleedout_PlayerMovementLimiter() ): 
Bleedout_DiableWallrunAndDoubleJump() and Bleedout_EnableWallrunAndDoubleJump()
existing, which will do a "OnClassChange" after being downed or revived, please notice!
maybe when bleeding player is wallrunning we FreezeControl could be better? like SlidePrevention()
*/
global function Bleedout_Init
global function Bleedout_StartPlayerBleedout
global function Bleedout_AddCallback_OnPlayerStartBleedout
global function Bleedout_AddCallback_OnPlayerGiveFirstAid
global function Bleedout_ShouldAIMissBleedingPlayer

const asset FX_BLOODTRAIL = $"skit_blood_decal_LG"
const float BLEEDOUT_MAX_USE_DIST2_MOD = 64 * 64

// modified function
global function Bleedout_EnableExecutingBleedingPlayer
global function Bleedout_AllowInterruptSelfRes

global function Bleedout_IsPlayerSelfHealing
global function Bleedout_IsPlayerGettingFirstAid

global function Bleedout_IsPlayerBleeding
global function Bleedout_GetLastAttacker
global function Bleedout_GetLastAttackerWeapon
//global function Bleedout_GetLastDamageInfo // no idea now
//global function Bleedout_IsRevivingFriendly // no idea how to make it

global function Bleedout_HealthRegenThink
global function Bleedout_SetHealthRegenRate

const bool BLEEDOUT_DEBUG = false
const asset BLEEDOUT_EXECUTION_HITBOX_MODEL = $"models/weapons/bullets/mgl_grenade.mdl"

global function Bleedout_SetProtectionDuration
global function Bleedout_SetIncapShieldHealth
global function Bleedout_SetIncapShieldInvulnerable

const float BLEEDOUT_PROTECTION_DURATION = 1.05
const int BLEEDOUT_INCAP_SHIELD_MAX_HEALTH = 350

struct IncapShieldStruct
{
	entity vortexSphere
	entity shieldWallFX1P
}

struct
{
	table<entity,bool> isBleeding
	table<entity, entity> IsGettingFirstAidFrom
	table<entity, entity> lastAttacker
	table<entity, entity> lastAttackerWeapon
	//table<entity, var> lastDamageInfo // no idea now
	// victim, attacker, damageInfo
	array<void functionref( entity, entity, var )> Callbacks_OnPlayerStartBleedout 
	// playerToRes, playerHealer
	array<void functionref( entity, entity )> Callbacks_OnPlayerGiveFirstAid 
	int firstAidAttemptID = 0 //The ID that identifies the first aid attempt. Used to distinguish between simultainous healing attempts on the client

	// modified variable
	bool executingBleedingEnabled = false
	bool selfResInterruptable = true
	float bleedoutHealthRegenRate = 4.0
	float bleedoutHealthRegenDelay = 4.0
	float protectionDuration = BLEEDOUT_PROTECTION_DURATION
	//table<entity, string> playerSavedTitle
	table<entity, int> incapShieldHealthTable
	int incapShieldMaxHealth = BLEEDOUT_INCAP_SHIELD_MAX_HEALTH
	//table<entity, IncapShieldStruct> playerIncapShieldTable // no need to use 1p things
	table<entity, entity> playerIncapShieldTable
	bool invulnerableIncapShield
	table<entity, entity> bleedoutFakePlayers
} file

void function Bleedout_Init()
{
	/* Registrations should be done in sh_bleedout_damage.gnut
	RegisterSignal( "BleedOut_StopBleeding" )
	RegisterSignal( "BleedOut_OnRevive" )
	RegisterSignal( "BleedOut_OnStartDying" )
	RegisterSignal( "OnContinousUseStopped" )

	// modifed signal
	RegisterSignal( "BleedoutHealthRegenThink" )
	RegisterSignal( "Bleedout_PlayerAttemptRes" )
	RegisterSignal( "Bleedout_OnStartReviving" )
	*/

	AddCallback_OnClientConnected( Bleedout_OnClientConnected )
	AddCallback_OnClientDisconnected( Bleedout_OnClientDisconnected )

	PrecacheParticleSystem( FX_BLOODTRAIL )
	PrecacheParticleSystem( $"death_pinkmist_LG_nochunk" )
	PrecacheParticleSystem( $"xo_damage_exp_2" )
}

void function Bleedout_OnClientConnected( entity player )
{
	file.isBleeding[ player ] <- false
	file.IsGettingFirstAidFrom[ player ] <- null
	file.lastAttacker[ player ] <- svGlobal.worldspawn
	file.lastAttackerWeapon[ player ] <- null
	//file.lastDamageInfo[ player ] <- null // no idea now
	//file.playerSavedTitle[ player ] <- ""
	file.incapShieldHealthTable[ player ] <- file.incapShieldMaxHealth
	file.playerIncapShieldTable[ player ] <- null
	file.bleedoutFakePlayers[ player ] <- null

	/*
	IncapShieldStruct emptyStruct
	emptyStruct.vortexSphere = null
	emptyStruct.shieldWallFX1P = null
	file.playerIncapShieldTable[ player ] <- emptyStruct
	*/
}

void function Bleedout_OnClientDisconnected( entity player )
{
	/* unhandled delete, no need for now
	delete file.isBleeding[ player ]
	delete file.IsGettingFirstAidFrom[ player ]
	delete file.lastAttacker[ player ]
	delete file.playerSavedTitle[ player ]
	delete file.incapShieldHealthTable[ player ]
	delete file.playerIncapShieldTable[ player ]
	*/
}

void function Bleedout_AddCallback_OnPlayerStartBleedout( void functionref(entity, entity, var) callback )
{
	file.Callbacks_OnPlayerStartBleedout.append( callback )
}

void function Bleedout_AddCallback_OnPlayerGiveFirstAid( void functionref(entity, entity) callback )
{
	file.Callbacks_OnPlayerGiveFirstAid.append( callback )
}

bool function Bleedout_StartPlayerBleedout( entity player, entity attacker, var damageInfo ) // victim, attacker, damageInfo
{
	//if the player is already bleeding don't restart bleeding logic.
	if ( file.isBleeding[ player ] )
		return false

	if ( Bleedout_GetDeathOnTeamBleedout() )
	{
		bool isLastPlayer = CheckForTeamBleedout( player )
		if( isLastPlayer )
		{
			// player will just die
			//player.Die( DamageInfo_GetAttacker( damageInfo ), DamageInfo_GetAttacker( damageInfo ), { damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo ) } )
			return false
		}
	}
	
	// starting bleedout!
	player.Signal( "BleedOut_StopBleeding" )
	player.Signal( "BleedOut_OnStartDying" )

	file.lastAttacker[ player ] = attacker
	file.lastAttackerWeapon[ player ] = DamageInfo_GetWeapon( damageInfo )
	//file.lastDamageInfo[ player ] = damageInfo // no idea now
	
	player.ClearParent()
	player.Anim_Stop() // interupt current executions etc.
	Bleedout_PlayerDownedSound( player, attacker )
	Bleedout_PlayerDownedEffect( player, damageInfo )
	Bleedout_PlayerDownedObit( player, attacker, damageInfo ) // now only shows to attacker!

	// this should done before callbacks since it triggers a "OnClassChange"
	// done using Bleedout_PlayerMovementLimiter()
	//Bleedout_DiableWallrunAndDoubleJump( player ) 

	EmitSoundOnEntityToTeam( player, "UI_Spawn_FriendlyPilot", player.GetTeam() )
	foreach( void functionref( entity, entity, var ) callbackFunc in file.Callbacks_OnPlayerStartBleedout )
	{
		//if ( IsValid( callbackFunc ) && !file.isBleeding[ player ] )
			//callbackFunc( player )
		callbackFunc( player, attacker, damageInfo )
	}

	thread Bleedout_DeathProtection( player )

	thread BloodTrail( player )
	thread PlayerDying( player )
	thread EnablePlayerRes( player )

	//Start selfhealing thread if enabled.
	if ( Bleedout_GetSelfResEnabled() )
		thread EnablePlayerSelfRes( player )

	// nessie mix, better support for killshot sounds
	//if ( Bleedout_GetDeathOnTeamBleedout() )
	//	CheckForTeamBleedout( player.GetTeam() )
	
	// bleedout successfully functioning
	return true
}

void function PlayerDying( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_OnRevive" )
	player.EndSignal( "BleedOut_OnStartDying" )

	float bleedoutTime = Bleedout_GetBleedoutTime()
	bool forceHolster = Bleedout_GetForceWeaponHolster()

	array<int> ids = []
	
	// slow effect in ttf2 can be too much powerful
	//ids.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.25 ) )
	//ids.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
	ids.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.2 ) )
	ids.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.2 ) )

	//if ( bleedoutTime > 0 )
	//	ids.append( StatusEffect_AddEndless( player, eStatusEffect.bleedoutDOF, 1.0 ) )

	file.isBleeding[ player ] = true

	//player.ForceCrouch() // handle in PlayerMovementLimiter()
	/*
	string playerTitle = player.GetTitle()
	if( playerTitle != "#DEATH_BLEEDOUT" && playerTitle !=  )
		file.playerSavedTitle[player] = playerTitle
	*/
	player.SetTitle( "#DEATH_BLEEDOUT" )
	player.SetOneHandedWeaponUsageOn()
	//thread Bleedout_PlayerSlidePrevention( player )
	thread Bleedout_PlayerMovementLimiter( player )
	thread Bleedout_ScreenFadeThink( player )
	thread Bleedout_EnemySpottingHighlight( player )
	thread Bleedout_IncapShieldThink( player )
	//thread Bleedout_FakePlayerThink( player ) // don't know how to do this

	if ( forceHolster )
	{
		//HolsterAndDisableWeapons( player )
		thread Bleedout_PlayerHolsterWeapon( player ) // better fix
	}

	OnThreadEnd(
	//function() : ( player, ids, forceHolster, playerTitle ) // i'm stupid sorry
	function() : ( player, ids, forceHolster )
		{
			if ( IsValid( player ) )
			{
				foreach ( id in ids )
					StatusEffect_Stop( player, id )

				file.isBleeding[ player ] = false
				file.lastAttacker[ player ] = svGlobal.worldspawn
				file.lastAttackerWeapon[ player ] = null
				//file.lastDamageInfo[ player ] = null  // no idea now

				//player.UnforceCrouch()
				thread Bleedout_PlayerForceStand( player )
				//player.SetTitle( file.playerSavedTitle[player] ) // no more this
				player.SetTitle( "" )
				player.SetOneHandedWeaponUsageOff()
				//Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_PlayerRevivedDOF" )

				if ( forceHolster )
					DeployAndEnableWeapons( player )

				//Hide wounded icon for wounded player's allies
				int woundedPlayerEHandle = player.GetEncodedEHandle()
				array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
				foreach ( entity teamPlayer in teamPlayers )
				{
					if ( teamPlayer == player )
						continue
					Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_BLEEDOUT_HideWoundedMarker", woundedPlayerEHandle )
				}
			}
		}
	)

	//if ( bleedoutTime > 0 )
	//	StatusEffect_AddTimed( player, eStatusEffect.bleedoutDOF, 1.0, bleedoutTime, 0.0 )
		//Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_StartDyingDOF", bleedoutTime )

	//Show wounded icon for wounded player's allies
	int woundedPlayerEHandle = player.GetEncodedEHandle()
	array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
	foreach ( entity teamPlayer in teamPlayers )
	{
		if ( teamPlayer == player )
			continue

		Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_BLEEDOUT_ShowWoundedMarker", woundedPlayerEHandle, Time(), Time() + bleedoutTime )
	}

	if ( bleedoutTime > 0 )
		wait bleedoutTime
	else
		WaitForever()
	
	if( Bleedout_IsPlayerGettingFirstAid( player ) )
		waitthread Bleedout_OverTimeFirstAid( player )
	if( player.ContextAction_IsActive() )
		waitthread Bleedout_OverTimeAnimation( player )

	if( IsAlive( player ) )
		PlayerDiesFromBleedout( player, file.lastAttacker[ player ] )
}

void function EnablePlayerRes( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_OnStartDying" )
	player.EndSignal( "BleedOut_OnRevive" )

	Highlight_SetFriendlyHighlight( player, "interact_object_los_line" )

	if ( IsPilotEliminationBased() )
		SetPlayerEliminated( player )

	OnThreadEnd(
	function() : ( player )
		{
			if ( IsValid( player ) )
			{
				player.UnsetUsable()
				Highlight_ClearFriendlyHighlight( player )
			}
		}
	)

	while ( true )
	{
		//If the player is not currently being treated or is self healing. (Team healing should always override self-healing)
		if ( !Bleedout_IsPlayerGettingFirstAid( player ) || Bleedout_IsPlayerSelfHealing( player ) )
		{
			player.SetUsableByGroup( "friendlies pilot" )
			player.SetUsePrompts( "#BLEEDOUT_USE_TEAMMATE_RES", "#BLEEDOUT_USE_TEAMMATE_RES_PC" )

			if( file.executingBleedingEnabled )
				thread Bleedout_BecomeExecutionTarget( player )
			entity playerHealer = expect entity ( player.WaitSignal( "OnPlayerUse" ).player )
			player.UnsetUsable()

			/* // tryed to adjust, not using right now
			entity playerHealer = expect entity ( player.WaitSignal( "OnPlayerUse", "BleedOut_OnStartReviving" ).player )
			player.UnsetUsable()
			if( Bleedout_IsPlayerSelfHealing( player ) ) // not showing prompts while selfres
			{
				WaitFrame()
				continue
			}
			*/

			//Player can only res other players if they are not bleeding out themselves.
			if ( !file.isBleeding[ playerHealer ] && ( !Bleedout_IsPlayerGettingFirstAid( player ) || Bleedout_IsPlayerSelfHealing( player ) ) )
				waitthread PlayerAttemptRes( playerHealer, player )
		}
		else
		{
			WaitFrame()
		}
	}
}

void function EnablePlayerSelfRes( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_OnStartDying" )
	player.EndSignal( "BleedOut_OnRevive" )

	while ( true )
	{
		if (  !Bleedout_IsPlayerGettingFirstAid( player ) )
			MessageToPlayer( player, eEventNotifications.BLEEDOUT_SelfHealPrompt )

		if ( player.UseButtonPressed() && !Bleedout_IsPlayerGettingFirstAid( player ) )
		{
			MessageToPlayer( player, eEventNotifications.Clear )
			waitthread PlayerAttemptRes( player, player )
		}

		WaitFrame()
	}
}

void function PlayerAttemptRes( entity playerHealer, entity playerToRes )
{
	Assert( IsNewThread(), "Must be threaded off." )
	playerToRes.Signal( "Bleedout_PlayerAttemptRes" ) // so teammates can interrupt selfRes
	//playerToRes.Signal( "Bleedout_OnStartReviving" ) // not using right now, needs untyped
	playerToRes.EndSignal( "OnDeath" )
	playerToRes.EndSignal( "OnDestroy" )
	playerToRes.EndSignal( "Bleedout_PlayerAttemptRes" )
	playerHealer.EndSignal( "OnDeath" )
	playerHealer.EndSignal( "OnDestroy" )
	playerHealer.EndSignal( "OnContinousUseStopped" )

	if( Bleedout_IsPlayerSelfHealing( playerToRes ) )
		WaitFrame() // do a extra wait if player was selfResing, this means a friendly is interupting their selfRes

	bool isSelfRes = playerHealer == playerToRes // different check, but works better
	
	/*
	string healerTitle = playerHealer.GetTitle()
	string playerTitle = playerToRes.GetTitle()
	if( healerTitle == "#BLEEDOUT_APPLYING_FIRST_AID" ||
		healerTitle == "#BLEEDOUT_RECIEVING_FIRST_AID" )
		healerTitle = "" // clear title if something goes wrong
	if( playerTitle == "#BLEEDOUT_APPLYING_FIRST_AID" ||
		playerTitle == "#BLEEDOUT_RECIEVING_FIRST_AID" )
		playerTitle = ""
	*/

	if( !isSelfRes )
	{
		EmitSoundOnEntityOnlyToPlayer( playerToRes, playerHealer, "pilot_healthpack_small_healing" )
		EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_small_healing" )
		playerHealer.SetTitle( "#BLEEDOUT_APPLYING_FIRST_AID" )
		playerToRes.SetTitle( "#BLEEDOUT_RECIEVING_FIRST_AID" )
	}
	else
	{
		EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_large_healing" )
		playerToRes.SetTitle( "#BLEEDOUT_APPLYING_FIRST_AID" )
	}

	if( !isSelfRes )
		HolsterAndDisableWeapons( playerHealer )

	playerHealer.MovementDisable()
	playerToRes.MovementDisable()

	float firstAidTime = playerHealer == playerToRes ? Bleedout_GetFirstAidTimeSelf() : Bleedout_GetFirstAidTime()
	float firstAidHealPercent = Bleedout_GetFirstAidHealPercent()

	float endTime = Time() + firstAidTime

	int playerEHandle = playerToRes.GetEncodedEHandle()
	int healerEHandle = playerHealer.GetEncodedEHandle()
	int attemptID = GetNewFirstAidAttemptID()

	Remote_CallFunction_NonReplay( playerToRes, "ServerCallback_BLEEDOUT_StartFirstAidProgressBar", endTime, playerEHandle, healerEHandle, attemptID )
	Remote_CallFunction_NonReplay( playerHealer, "ServerCallback_BLEEDOUT_StartFirstAidProgressBar", endTime, playerEHandle, healerEHandle, attemptID )
	file.IsGettingFirstAidFrom[ playerToRes ] = playerHealer

	OnThreadEnd(
	//function() : ( playerHealer, playerToRes, attemptID, isSelfRes, healerTitle, playerTitle )
	// never gonna fix it
	function() : ( playerHealer, playerToRes, attemptID, isSelfRes )
		{
			if ( IsValid( playerHealer ) )
			{
				if ( IsValid( playerToRes ) )
				{
					if( !isSelfRes )
					{
						if( file.isBleeding[ playerToRes ] ) // interrupted revive
							EmitSoundOnEntityOnlyToPlayer( playerToRes, playerHealer, "pilot_healthpack_drop" )
						else
							EmitSoundOnEntityOnlyToPlayer( playerToRes, playerHealer, "pilot_healthpack_small_healing_end" )
					}
				}
				if( !isSelfRes )
				{
					DeployAndEnableWeapons( playerHealer )
					//playerHealer.SetTitle( healerTitle ) // try to fix this
				}
				playerHealer.SetTitle( "" )
				playerHealer.MovementEnable()
				Remote_CallFunction_NonReplay( playerHealer, "ServerCallback_BLEEDOUT_StopFirstAidProgressBar", attemptID )
			
			}

			if ( IsValid( playerToRes ) )
			{
				file.IsGettingFirstAidFrom[ playerToRes ] = null
				playerToRes.MovementEnable()
				Remote_CallFunction_NonReplay( playerToRes, "ServerCallback_BLEEDOUT_StopFirstAidProgressBar", attemptID )
				StopSoundOnEntity( playerToRes, "pilot_healthpack_small_healing" )
				StopSoundOnEntity( playerToRes, "pilot_healthpack_large_healing" )
				playerToRes.SetTitle( "" )

				if( file.isBleeding[ playerToRes ] ) // interrupted revive
				{
					//playerToRes.SetTitle( playerTitle ) // try to fix this
					if( isSelfRes )
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_drop" )
					else
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_drop" )
					playerToRes.SetTitle( "#DEATH_BLEEDOUT" )
				}
				else
				{
					if( isSelfRes )
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_large_healing_end" )
					else
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_small_healing_end" )
				}
			}
		}
	)
#if BLEEDOUT_DEBUG
	waitthread DEBUG_AutoUsePress( playerHealer, playerToRes, firstAidTime )
#else
	waitthread TrackContinuousUse( playerHealer, playerToRes, firstAidTime, true )
#endif

	file.isBleeding[ playerToRes ] = false
	file.lastAttacker[ playerToRes ] = svGlobal.worldspawn
	file.lastAttackerWeapon[ playerToRes ] = null
	//file.lastDamageInfo[ playerToRes ] = null // no idea now
	if ( IsPilotEliminationBased() )
		ClearPlayerEliminated( playerToRes )

	// this should done before callbacks since it triggers a "OnClassChange"
	// done using Bleedout_PlayerMovementLimiter()
	//Bleedout_EnableWallrunAndDoubleJump( playerToRes )

	foreach( void functionref( entity, entity ) callbackFunc in file.Callbacks_OnPlayerGiveFirstAid )
	{
		//if ( IsValid( callbackFunc ) )
		//{
			//Do not run this callback if player is self healing.
		//	if ( playerHealer != playerToRes )
		//		callbackFunc( playerHealer )
		//}
		callbackFunc( playerToRes, playerHealer )
	}
	//Heal player health
	playerToRes.SetHealth( playerToRes.GetMaxHealth() * firstAidHealPercent )

	playerToRes.Signal( "BleedOut_OnRevive" )

}

void function BloodTrail( entity player )
{
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	player.EndSignal( "OnDeath")

	while ( true )
	{
		float interval = RandomFloatRange( 0.25, 0.5 )
		PlayFXOnEntity( FX_BLOODTRAIL, player )
		wait interval
	}
}

void function PlayerDiesFromBleedout( entity player, entity attacker )
{
	if ( IsValid( attacker ) )
	{
		player.Die( attacker, attacker, { damageSourceId = eDamageSourceId.bleedout } )
		//player.BecomeRagdoll( Vector(0,0,0), false )
	}
	else
	{
		player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { damageSourceId = eDamageSourceId.bleedout } )
		//player.BecomeRagdoll( Vector(0,0,0), false )
	}


}

//This function checks to see if all players on a team are dead or bleeding out.
//If all the players are dead/bleeding out, it kills the surviving team players.
// use this to better support killshot sound
//void function CheckForTeamBleedout( int team )
bool function CheckForTeamBleedout( entity player )
{
	array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
	foreach ( entity teamPlayer in teamPlayers )
	{
		if( teamPlayer == player )
			continue
		if ( IsAlive( teamPlayer ) && !file.isBleeding[ teamPlayer ] )
			return false
	}

	//All players on team are bleeding out
	foreach ( entity teamPlayer in teamPlayers )
	{
		// doing a check in sh_bleedout_damage.gnut, last survivor will take correct damageSource instead of "Bleed out"
		if( player == teamPlayer )
			continue
		if ( IsAlive( teamPlayer ) )
			PlayerDiesFromBleedout( teamPlayer, file.lastAttacker[ teamPlayer ] )
	}
	return true
}

bool function Bleedout_ShouldAIMissBleedingPlayer( entity player )
{
	//If the player is not bleeding
	if ( !file.isBleeding[ player ] )
		return false

	//If the bleedout settings don't affect AI accuracy.
	if ( !Bleedout_ShouldAIMissPlayer() )
		return false

	return true
}

//bool function Bleedout_IsPlayerGettingFirstAid( entity player ) // function name adjustment
bool function Bleedout_IsPlayerGettingFirstAid( entity player )
{
	if( !( player in file.IsGettingFirstAidFrom ) )
		return false
	return file.IsGettingFirstAidFrom[ player ] != null
}

//bool function IsPlayerSelfHealing( entity player ) // function name adjustment
bool function Bleedout_IsPlayerSelfHealing( entity player )
{
	if( !( player in file.IsGettingFirstAidFrom ) )
		return false
	return file.IsGettingFirstAidFrom[ player ] == player
}

//////////////
//Utilities
//////////////
void function TrackContinuousUse( entity player, entity useTarget, float useTime, bool doRequireUseButtonHeld )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	useTarget.EndSignal( "OnDeath" )
	useTarget.EndSignal( "OnDestroy" )

	table result = {}
	result.success <- false
	result.unsetUsable <- false

	float maxDist2 = DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) + BLEEDOUT_MAX_USE_DIST2_MOD

	OnThreadEnd
	(
		function() : ( player, useTarget, result )
		{
			if ( !result.success )
			{
				if( IsValid( player ) )
					player.Signal( "OnContinousUseStopped" )
			}
			if( result.unsetUsable )
			{
				if( IsAlive( useTarget ) )
				{
					useTarget.SetUsableByGroup( "friendlies pilot" )
					useTarget.SetUsePrompts( "#BLEEDOUT_USE_TEAMMATE_RES", "#BLEEDOUT_USE_TEAMMATE_RES_PC" )
				}
			}
		}
	)

	bool isSelfUse = player == useTarget
	float startTime = Time()
	if( isSelfUse && !file.selfResInterruptable )
	{
		// prevent almostDoned selfRes being interrupt
		player.UnsetUsable()
		result.unsetUsable = true
	}
	
	while ( Time() < startTime + useTime && (!doRequireUseButtonHeld || player.UseButtonPressed()) && !player.IsPhaseShifted() && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
	{
		if( player.ContextAction_IsActive() ) // being interupted by executions!
			return
		if( !isSelfUse && Bleedout_IsPlayerBleeding( player ) ) //being downed during reviving teammates!
			return
		WaitFrame()
	}

	if ( ( !doRequireUseButtonHeld || player.UseButtonPressed() ) && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2  )
		result.success = true
}

void function DEBUG_AutoUsePress( entity player, entity useTarget, float useTime )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	useTarget.EndSignal( "OnDeath" )
	useTarget.EndSignal( "OnDestroy" )

	table result = {}
	result.success <- false
	result.unsetUsable <- false

	float maxDist2 = DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) + BLEEDOUT_MAX_USE_DIST2_MOD

	OnThreadEnd
	(
		function() : ( player, useTarget, result )
		{
			if ( !result.success )
			{
				if( IsValid( player ) )
					player.Signal( "OnContinousUseStopped" )
			}
			if( result.unsetUsable )
			{
				if( IsAlive( useTarget ) )
				{
					useTarget.SetUsableByGroup( "friendlies pilot" )
					useTarget.SetUsePrompts( "#BLEEDOUT_USE_TEAMMATE_RES", "#BLEEDOUT_USE_TEAMMATE_RES_PC" )
				}
			}
		}
	)

	bool isSelfUse = player == useTarget
	float startTime = Time()
	if( isSelfUse && !file.selfResInterruptable )
	{
		// prevent almostDoned selfRes being interrupt
		player.UnsetUsable()
		result.unsetUsable = true
	}
	
	while ( Time() < startTime + useTime && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
	{
		if( Time() >= startTime + 0.5 && player.IsInputCommandHeld( IN_USE ) ) // manually stop
			return
		if( player.ContextAction_IsActive() ) // being interupted by executions!
			return
		if( !isSelfUse && Bleedout_IsPlayerBleeding( player ) ) // being downed during reviving teammates!
			return
		WaitFrame()
	}

	if ( DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
		result.success = true
}

int function GetNewFirstAidAttemptID()
{
	file.firstAidAttemptID += 1
	return file.firstAidAttemptID
}

// modified function
void function Bleedout_EnableExecutingBleedingPlayer( bool enable )
{
	file.executingBleedingEnabled = enable
}

void function Bleedout_AllowInterruptSelfRes( bool allow )
{
	file.selfResInterruptable = allow
}

bool function Bleedout_IsPlayerBleeding( entity player )
{
	if( !( player in file.isBleeding ) )
		return false
	return file.isBleeding[player]
}

entity function Bleedout_GetLastAttacker( entity player )
{
	if( !( player in file.lastAttacker ) )
		return null
	return file.lastAttacker[player]
}

entity function Bleedout_GetLastAttackerWeapon( entity player )
{
	if( !( player in file.lastAttackerWeapon ) )
		return null
	return file.lastAttackerWeapon[player]
}

 // no idea now
//var function Bleedout_GetLastDamageInfo( entity player )
//{
//	if( !( player in file.lastDamageInfo ) )
//		return null
//	return file.lastDamageInfo[player]
//}

// no idea
//bool function Bleedout_IsRevivingFriendly( entity player )
//{
//	return 
//}

void function Bleedout_OverTimeFirstAid( entity player )		
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	while( true )
	{
		WaitFrame()
		if( Bleedout_IsPlayerGettingFirstAid( player ) )
			continue
		else
			break
	}
}

void function Bleedout_PlayerDownedSound( entity victim, entity attacker )
{
	if( attacker.IsPlayer() )
	{
		if( victim.IsMechanical() )
		{
			//if( attacker != victim )
			//	EmitSoundOnEntityOnlyToPlayer( victim, attacker, "android_bulletimpact_killshot_1p_vs_3p" )
			EmitSoundOnEntityExceptToPlayer( victim, attacker, "android_bulletimpact_killshot_3p_vs_3p" )
		}
		else
		{
			//if( attacker != victim )
			//	EmitSoundOnEntityOnlyToPlayer( victim, attacker, "flesh_bulletimpact_killshot_1p_vs_3p" )
			EmitSoundOnEntityExceptToPlayer( victim, attacker, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
		}
	}
	else
	{
		if( victim.IsMechanical() )
			EmitSoundOnEntity( victim, "android_bulletimpact_killshot_3p_vs_3p" )
		else
			EmitSoundOnEntity( victim, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
	}
}

void function Bleedout_PlayerDownedEffect( entity player, var damageInfo )
{
	if( !( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BULLET ) ) // not a bullet damage type
		return
	if( player.IsMechanical() )
	{
		int particleIndex = GetParticleSystemIndex( $"xo_damage_exp_2" )
		int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
		entity fx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		SetTeam( fx, player.GetTeam() )
		fx.SetOwner( player )
		fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
		thread FastStopParticle( fx, 2.5 )
		entity ownerFx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		fx.SetOwner( player )
		fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
		thread FastStopParticle( fx, 1.0 )
	}
	else
	{
		int particleIndex = GetParticleSystemIndex( $"death_pinkmist_LG_nochunk" )
		int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
		StartParticleEffectOnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	}
}

void function FastStopParticle( entity fx, float delay )
{
	fx.EndSignal( "OnDestroy" )
	wait delay
	EffectStop( fx )
}

void function Bleedout_PlayerDownedObit( entity ent, entity attacker, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	// trigger_hurt is no longer networked, so the "attacker" fails to display obituaries
	if ( attacker )
	{
		if( !attacker.IsPlayer() || ent == attacker ) // now only shows to attacker!
			return

		string attackerClassname = attacker.GetClassName()

		if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
			attacker = GetEntByIndex( 0 ) // worldspawn
	}

	int attackerEHandle = attacker ? attacker.GetEncodedEHandle() : -1

	int victimEHandle = ent.GetEncodedEHandle()
	int scriptDamageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( scriptDamageType & DF_VORTEX_REFIRE )
		damageSourceId = eDamageSourceId.mp_titanweapon_vortex_shield

	if ( IsValidHeadShot( damageInfo, ent ) )
		scriptDamageType = scriptDamageType | DF_HEADSHOT
	else
		scriptDamageType = scriptDamageType & (~DF_HEADSHOT)
	
	// now only shows to attacker!
	Remote_CallFunction_NonReplay( attacker, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	//foreach ( entity player in GetPlayerArray() )
	//{
		//if( player != ent )
			//Remote_CallFunction_NonReplay( player, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	//}
}

void function Bleedout_DeathProtection( entity player )
{
	player.SetInvulnerable()
	wait file.protectionDuration
	if( IsValid( player ) )
		player.ClearInvulnerable()
}

void function Bleedout_PlayerMovementLimiter( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	//bool lastFrameSlide // for checks

	OnThreadEnd(
		function(): ( player )
		{
			if( IsValid( player ) )
			{
				player.UnforceCrouch()
				player.SetGroundFrictionScale( 1 )
			}
		}
	)

	while( true )
	{
		player.ForceCrouch()
		player.SetGroundFrictionScale( 9999 ) // really high to prevent sliding
		player.ConsumeDoubleJump()
		WaitFrame()
	}
}

void function Bleedout_PlayerSlidePrevention( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	//bool lastFrameSlide // for checks
	while( true )
	{
		WaitFrame()
		if( player.IsSliding() && player.IsOnGround() ) // sometimes sliding off a roof will remain slide state, do a check
		{
			player.SetVelocity( < 0,0,0 > )
		//	lastFrameSlide = true
		//	continue
		}
		//if( lastFrameSlide && !player.IsOnGround() ) // prevent player being stopped midair
		//	player.SetVelocity( < 0,0,100 > )
		//lastFrameSlide = false
	}
}

void function Bleedout_DiableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	if( !settingMods.contains( "disable_wallrun" ) )
		settingMods.append( "disable_wallrun" )
	if( !settingMods.contains( "disable_doublejump" ) )
		settingMods.append( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_EnableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	settingMods.removebyvalue( "disable_wallrun" )
	settingMods.removebyvalue( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_PlayerHolsterWeapon( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function():( player )
		{
			if( IsValid( player ) )
				player.Server_TurnOffhandWeaponsDisabledOff()
		}
	)

	HolsterAndDisableWeapons( player )
	while( true )
	{
		player.HolsterWeapon()
		player.Server_TurnOffhandWeaponsDisabledOn()
		WaitFrame()
	}
}

void function Bleedout_PlayerForceStand( entity player )
{
	player.UnforceCrouch()
	player.ForceStand()
	wait 0.2
	if( IsValid( player ) )
		player.UnforceStand()
}

void function Bleedout_EnemySpottingHighlight( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			Highlight_ClearEnemyHighlight( player )
		}
	)

	while( true )
	{
		Highlight_SetEnemyHighlight( player, "sp_enemy_pilot" )
		player.Highlight_SetParam( 2, 0, < 2,0,0 > )
		WaitFrame()
	}
}

void function Bleedout_BecomeExecutionTarget( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	wait file.protectionDuration // do need this to prevent execution invulnerable players

	entity hitBox = CreateHitboxEntityForPlayer( player )
	hitBox.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( hitBox )
		{
			//print( "hitBox Think End" )
			if( IsValid( hitBox ) )
				hitBox.Destroy()
		}
	)

	while( true )
	{
		// temp unsetUsable() when player getting firstaid by friendlies
		if( Bleedout_IsPlayerGettingFirstAid( player ) && !Bleedout_IsPlayerSelfHealing( player ) )
		{
			hitBox.UnsetUsable()
			//print( "hitBox being UnsetUsable()" )
		}
		else if( !player.ContextAction_IsActive() ) // assuming this is player being executing, wait for it
		{	
			hitBox.SetUsableByGroup( "enemies pilot" )
			//print( "hitBox being SetUsable()" )
		}

		// defensive fixs( actually messed things up
		/*
		if( !player.ContextAction_IsActive() ) 
		{
			hitBox.SetUsableByGroup( "enemies pilot" )
			//print( "hitBox being SetUsable()" )
		}
		else
		{
			hitBox.UnsetUsable()
			//print( "hitBox being UnsetUsable()" )
		}
		*/
		WaitFrame()
	}
}

entity function CreateHitboxEntityForPlayer( entity player )
{
	entity hitBox = CreatePropScript( BLEEDOUT_EXECUTION_HITBOX_MODEL )
	hitBox.SetParent( player, "CHESTFOCUS" )
	//hitBox.SetOrigin( < 30, 0, 0 > )
	//hitBox.SetLocalAngles( < 90, -90, 0 > )
	hitBox.SetTakeDamageType( DAMAGE_NO )
	SetTeam( hitBox, player.GetTeam() )
	SetObjectCanBeMeleed( hitBox, false )
	//hitBox.kv.modelscale = 0.1
	hitBox.kv.solid = SOLID_VPHYSICS
	hitBox.Hide()
	
	hitBox.SetOwner( player )
	
    hitBox.SetUsableByGroup( "enemies pilot" )
    hitBox.SetUsePrompts( "在目標身後按住 %use% 進行處決", "在目標身後按下 %use% 進行處決" )

    AddCallback_OnUseEntity( hitBox, ExecuteHitboxOwner )
	return hitBox
}

var function ExecuteHitboxOwner( var hitBox, var player )
{
	expect entity( player )
	expect entity( hitBox )
	thread ExecuteHitboxOwner_Threaded( hitBox, player )
}

void function ExecuteHitboxOwner_Threaded( entity hitBox, entity player )
{
	entity owner = hitBox.GetOwner()
	
	hitBox.UnsetUsable()
	// avoid this kind of crash... redo a SetUsable
	if( player.ContextAction_IsActive() ) // doing a execution?
		return
	if( file.isBleeding[ player ] ) // dont let downed players execute each other :(
		return
	if( !IsAlive( owner ) ) // owner may died before executions starts
		return
	if( owner.GetTeam() == player.GetTeam() ) // well this can't fix wrong notifications caused by swiching team
	{
		WaitFrame()
		if( IsValid( hitBox ) )
		{
			hitBox.SetUsableByGroup( "enemies pilot" )
		}
		return
	}

	SyncedMeleeChooser ornull actions = GetSyncedMeleeChooserForPlayerVsTarget( player, owner )
	if( actions == null )
		return
	expect SyncedMeleeChooser( actions )
	SyncedMelee ornull action = FindBestSyncedMelee( player, owner, actions )
	if( action == null )
		return
	expect SyncedMelee( action )
	thread Bleedout_PlayerSyncedMeleeEffect( player ) // screen effect
	thread Bleedout_PlayerSyncedMeleeEffect( owner )
	waitthread MeleeThread_PilotVsEnemy( action, player, owner )
	
	if( IsValid( hitBox ) )
	{
		if( !IsAlive( owner ) ) // owner died
			hitBox.Destroy()
		else
		{
			hitBox.SetUsableByGroup( "enemies pilot" )
		}
	}
}

void function Bleedout_PlayerSyncedMeleeEffect( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function() : ( player )
		{
			if ( IsValid( player ) )
			{
				RemoveCinematicFlag( player, CE_FLAG_EXECUTION )
                RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
			}
		}
	)

    AddCinematicFlag( player, CE_FLAG_EXECUTION )
    AddCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )

    WaittillAnimDone( player )
}

void function Bleedout_OverTimeAnimation( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	while( true )
	{
		WaitFrame()
		if( player.ContextAction_IsActive() )
			continue
		else
			break
	}
}

void function Bleedout_IncapShieldThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	// before OnThreadEnd()
	array<int> statusEffectHandles = []

	OnThreadEnd(
		function(): ( player, statusEffectHandles )
		{
			if( IsValid( player ) )
			{
				/* // abandoned
				entity vortexSphere = file.playerIncapShieldTable[ player ].vortexSphere
				entity shieldWallFX1P = file.playerIncapShieldTable[ player ].shieldWallFX1P
				if( IsValid( vortexSphere ) )
					vortexSphere.Destroy()
				if( IsValid( shieldWallFX1P ) )
					shieldWallFX1P.Destroy()
				*/
				entity vortexSphere = file.playerIncapShieldTable[ player ]
				if( IsValid( vortexSphere ) )
					vortexSphere.Destroy()
				
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
		}
	)
	
	wait BLEEDOUT_PROTECTION_DURATION *0.5
	entity vortexSphere = CreateIncapShieldForBleedingPlayer( player )
	vortexSphere.EndSignal( "OnDestroy" )

	float lastDryFireTime = 0
	bool vortexShown = false
	bool hasStatusEffect = true
	while( true )
	{
		WaitFrame()

		// not holding attack or be in special state
		if( IsInValidIncapShieldState( player ) && player.IsInputCommandHeld( IN_ATTACK ) ) 
		{
			if( !hasStatusEffect )
			{
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.5 ) )
				//statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
				hasStatusEffect = true
			}

			if( !vortexShown )
			{
				EmitSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
				HACK_ShowIncapShieldVortexSphere( vortexSphere, player ) // hacking function
				CreateIncapShieldWallFX( vortexSphere )
				vortexShown = true
			}
			if( IsValid( vortexSphere.e.shieldWallFX ) )
				EffectSetControlPointVector( vortexSphere.e.shieldWallFX, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
			
		}
		else// if( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			//print( "Stopping Incap Shield" )
			StopSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
			StopIncapShieldWallFX( vortexSphere )
			HACK_TempHideIncapShieldVortexSphere( vortexSphere ) // hacking function
			vortexShown = false
			if( hasStatusEffect )
			{
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
			hasStatusEffect = false
		}
	}

	/* // really should rework this
	while( true )
	{
		WaitFrame()
		//print( file.IsGettingFirstAidFrom[ player ] == player )

		// this continued everything, fuck me
		//if( !IsInValidIncapShieldState( player ) )
		//	continue

		if( file.incapShieldHealthTable[ player ] == 0 )
		{
			if( lastDryFireTime + 1.0 <= Time() && player.IsInputCommandHeld( IN_ATTACK ) )
			{
				EmitSoundOnEntityOnlyToPlayer( player, player, "pistol_dryfire" )
				lastDryFireTime = Time()
			}
			continue
		}

		//entity vortexSphere = file.playerIncapShieldTable[ player ].vortexSphere
		entity vortexSphere = file.playerIncapShieldTable[ player ]
		//print( IsValid( vortexSphere ) )
		//print( "Bleedout_IsPlayerGettingFirstAid( player ) = " + string( Bleedout_IsPlayerGettingFirstAid( player ) ) )
		//print( "Bleedout_IsPlayerSelfHealing( player ) = " + string( Bleedout_IsPlayerSelfHealing( player ) ) )
		//print( "player.ContextAction_IsActive() = " + string( player.ContextAction_IsActive() ) )
		//print( IsInValidIncapShieldState( player ) )

		// not holding attack or be in special state
		if( IsInValidIncapShieldState( player ) && player.IsInputCommandHeld( IN_ATTACK ) ) 
		{
			//print( "Looping Here but doing nothing" )
			//print( "Looping Here!!" )
			if( !IsValid( vortexSphere ) ) // new vortex
			{
				//print( "ReCreating Incap Shield" )
				CreateIncapShieldForBleedingPlayer( player )
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.5 ) )
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
			}
			else // last vortexSphere exists
			{
				EffectSetControlPointVector( vortexSphere.e.shieldWallFX, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
				if( !loopSoundPlaying )
				{
					EmitSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
					loopSoundPlaying = true
				}
			}
			
		}
		else// if( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			if( IsValid( vortexSphere ) )
			{
				//print( "Stopping Incap Shield" )
				StopSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
				loopSoundPlaying = false
				vortexSphere.Destroy()
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
		}
	}
	*/
}

void function UpdateShieldPosition( entity mover, entity owner )
{
	mover.NonPhysicsMoveTo( owner.GetOrigin(), 0.1, 0.0, 0.0 )
	vector angles = owner.EyeAngles()
	float yaw = angles.y
	yaw %= 360
	mover.NonPhysicsRotateTo( <0,yaw,180>, 1.35, 0, 0 )

//	float yaw = GetYawForEnemyOrLKP( owner )
//	float boost = sin( Time() * 1.5 ) * 65
//	yaw += boost
//	yaw %= 360
//	mover.NonPhysicsRotateTo( <0,yaw,0>, 0.95, 0, 0 )
}

bool function IsInValidIncapShieldState( entity player )
{
	if( Bleedout_IsPlayerGettingFirstAid( player ) ||
		Bleedout_IsPlayerSelfHealing( player ) ||
		player.ContextAction_IsActive() )
		return false

	return true
}

// should set a different one since it has been redirected
const int INCAP_SHIELD_RADIUS = 35
const int INCAP_SHIELD_HEIGHT = 60
const int INCAP_SHIELD_FOV = 75

const asset INCAP_SHIELD_EFFECT_NAME = $"P_anti_titan_shield_3P"

entity function CreateIncapShieldForBleedingPlayer( entity player )
{
	vector angles = VectorToAngles( player.EyeAngles() )
	int maxHealth = file.incapShieldMaxHealth
	int health = file.incapShieldHealthTable[ player ]

	// doing hardcode here, guess no need to change( and I cant easily change it
	// vortexSphere
	entity vortexSphere = CreateShieldWithSettings( player.GetOrigin(), angles, INCAP_SHIELD_RADIUS, INCAP_SHIELD_HEIGHT, INCAP_SHIELD_FOV, 9999, maxHealth, INCAP_SHIELD_EFFECT_NAME )
	//file.playerIncapShieldTable[ player ].vortexSphere = vortexSphere // no need to use 1p things
	file.playerIncapShieldTable[ player ] = vortexSphere
	
	vortexSphere.SetHealth( health )
	vortexSphere.SetOwner( player )
	vortexSphere.SetBlocksRadiusDamage( true )
	SetTeam( vortexSphere, player.GetTeam() )
	vortexSphere.SetParent( player, "ORIGIN" )
	vortexSphere.e.shieldWallFX.SetAngles( < 20,0,94 > )
	vortexSphere.e.shieldWallFX.SetOrigin( < 31,0,32 > )
	
	vortexSphere.SetDamageNotifications( false ) // no hitmarkers?
	if( file.invulnerableIncapShield )
	{
		vortexSphere.SetInvulnerable()
		vortexSphere.SetTakeDamageType( DAMAGE_NO )
	}
	else
	{	
		// this thing don't work for a vortexSphere?
		//AddEntityCallback_OnDamaged( vortexSphere, IncapShieldTableUpdate )
		thread TrackPlayerIncapShieldHealth( vortexSphere, player )
	}

	return vortexSphere
	

	// temp
	//vortexSphere.e.shieldWallFX.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY)

	/*
	// Shield wall fx control point
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	// Shield wall fx
	entity shieldWallFX1P = StartParticleEffectInWorld_ReturnEntity( GetParticleSystemIndex( $"P_anti_titan_shield_3P" ), < 20,0,48 >, < 20,0,95 > )
	file.playerIncapShieldTable[ player ].shieldWallFX1P = shieldWallFX1P

	shieldWallFX1P.SetOwner( player )
	shieldWallFX1P.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
	EffectSetControlPointVector( shieldWallFX1P, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
	shieldWallFX1P.SetParent( vortexSphere )

	thread Stop1PFXOnDestroy( vortexSphere, shieldWallFX1P )
	*/
}

void function HACK_ShowIncapShieldVortexSphere( entity vortexSphere, entity player )
{
	vortexSphere.SetParent( player, "ORIGIN" )
}

void function HACK_TempHideIncapShieldVortexSphere( entity vortexSphere )
{
	vortexSphere.ClearParent()
	vortexSphere.SetOrigin( < -9999, -9999, -9999 > ) // so player can never hit it
}

void function StopIncapShieldWallFX( entity vortexSphere )
{
	entity shieldWallFX = vortexSphere.e.shieldWallFX
	if( !IsValid( shieldWallFX ) )
		return

	entity cpoint = shieldWallFX.e.cpoint
	shieldWallFX.e.cpoint = null
	if( IsValid( cpoint ) )
		cpoint.Destroy()

	StopShieldWallFX( vortexSphere )
}

entity function CreateIncapShieldWallFX( entity vortexSphere )
{
	// Shield wall fx control point
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	// Shield wall fx
	entity shieldWallFX = PlayFXWithControlPoint( INCAP_SHIELD_EFFECT_NAME, < 0,0,0 >, cpoint, -1, null, < 0,0,0 >, C_PLAYFX_LOOP )
	vortexSphere.e.shieldWallFX = shieldWallFX
	shieldWallFX.e.cpoint = cpoint
	shieldWallFX.SetParent( vortexSphere )
	shieldWallFX.SetAngles( < 20,0,94 > )
	shieldWallFX.SetOrigin( < 31,0,32 > )

	return shieldWallFX
}

void function Bleedout_SetIncapShieldInvulnerable( bool invulnerable )
{
	file.invulnerableIncapShield = invulnerable
}

void function Stop1PFXOnDestroy( entity vortexSphere, entity shieldWallFX1P )
{
	vortexSphere.EndSignal( "OnDestroy" )
	shieldWallFX1P.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( vortexSphere, shieldWallFX1P )
		{
			if( IsValid( shieldWallFX1P ) )
				shieldWallFX1P.Destroy()
		}
	)

	WaitForever()
}

const vector BLEEDOUT_INCAP_SHIELD_COLOR_FULL		 = <115, 247, 255>	// blue
const vector BLEEDOUT_INCAP_SHIELD_COLOR_MED		 = <200, 128, 80>	// orange
const vector BLEEDOUT_INCAP_SHIELD_COLOR_EMPTY		 = <200, 80, 80>	// red

vector function GetIncapShieldCurrentColor( float chargeFrac, vector fullHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_FULL, vector medHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_MED, vector emptyHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_EMPTY )
{
	return GetTriLerpColor( chargeFrac, fullHealthColor, medHealthColor, emptyHealthColor )
}

// Copied from vortex, since it's not a global func
vector function GetTriLerpColor( float fraction, vector color1, vector color2, vector color3 )
{
	float crossover1 = 0.55  // from zero to this fraction, fade between color1 and color2
	float crossover2 = 0.75 // from crossover1 to this fraction, fade between color2 and color3

	float r, g, b

	// 0 = full charge, 1 = no charge remaining
	if ( fraction < crossover1 )
	{
		r = Graph( fraction, 0, crossover1, color1.x, color2.x )
		g = Graph( fraction, 0, crossover1, color1.y, color2.y )
		b = Graph( fraction, 0, crossover1, color1.z, color2.z )
		return <r, g, b>
	}
	else if ( fraction < crossover2 )
	{
		r = Graph( fraction, crossover1, crossover2, color2.x, color3.x )
		g = Graph( fraction, crossover1, crossover2, color2.y, color3.y )
		b = Graph( fraction, crossover1, crossover2, color2.z, color3.z )
		return <r, g, b>
	}
	else
	{
		// for the last bit of overload timer, keep it max danger color
		r = color3.x
		g = color3.y
		b = color3.z
		return <r, g, b>
	}

	unreachable
}

// why vortex_sphere don't have a damaged callback?
void function IncapShieldTableUpdate( entity vortexSphere, var damageInfo )
{
	//print( "try to update incap shield health!" )
	entity owner = vortexSphere.GetOwner()
	if( !IsValid( owner ) )
		return
	float baseDamage = DamageInfo_GetDamage( damageInfo )
	float damageDifference = vortexSphere.GetHealth() - baseDamage
	if( baseDamage >= 300 ) // basically for krabers
		baseDamage = 300
	if( damageDifference < 0 ) // shield broke damage
	{
		owner.TakeDamage( fabs( damageDifference ), 
						  DamageInfo_GetAttacker( damageInfo ), 
						  DamageInfo_GetInflictor( damageInfo ), 
						  { // damage table
							weapon = DamageInfo_GetWeapon( damageInfo ), 
						    origin = DamageInfo_GetDamagePosition( damageInfo ), 
							force = DamageInfo_GetDamageForce( damageInfo ), 
							scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
							damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo ) 
						  } )
		file.incapShieldHealthTable[ owner ] = 0
		return
	}
	int calcDamage = file.incapShieldHealthTable[ owner ] - int( DamageInfo_GetDamage( damageInfo ) )
	file.incapShieldHealthTable[ owner ] = int( max( calcDamage, 0 ) )
	//print( "incap Shield health left: "+ string( file.incapShieldHealthTable[ owner ] ) )
}

void function TrackPlayerIncapShieldHealth( entity vortexSphere, entity player )
{
	vortexSphere.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function():( vortexSphere, player )
		{
			if( !IsValid( vortexSphere ) )
			{
				file.incapShieldHealthTable[ player ] = 0
				//print( "incap Shield down" )
			}
			if( IsValid( player ) )
			{
				file.incapShieldHealthTable[ player ] = file.incapShieldMaxHealth // restore shield
				if( file.isBleeding[player] ) // otherwise player has been revived
					EmitSoundOnEntity( player, "ShieldWall_Destroyed" )
			}
		}
	)

	int lastTickHealth = vortexSphere.GetHealth()
	while( true )
	{
		int calcDamage = lastTickHealth - vortexSphere.GetHealth()
		file.incapShieldHealthTable[ player ] = int( max( file.incapShieldHealthTable[ player ] - calcDamage, 0 ) )

		lastTickHealth = vortexSphere.GetHealth()
		//print( "incap Shield health left: "+ string( file.incapShieldHealthTable[ player ] ) )
		WaitFrame()
	}
}

void function Bleedout_ScreenFadeThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			if( IsValid( player ) )
			{
				ScreenFade( player, 0, 0, 0, 125, 0.1, 0.1, FFADE_IN | FFADE_PURGE )
			}
		}
	)

	float bleedingTime = Bleedout_GetBleedoutTime()

	wait bleedingTime * 0.5
	
	ScreenFade( player, 0, 0, 0, 225, bleedingTime * 0.5, 999, FFADE_OUT | FFADE_PURGE )
	WaitForever()
}

void function Bleedout_FakePlayerThink( entity player ) // don't know how to do this
{
	float fadeDist 	= 10000.0
	int solidType = 0// 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only

	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
	entity fakePlayer = CreatePropDynamic( player.GetModelName(), < 0,0,0 >, < 0,0,0 >, solidType, fadeDist )
	fakePlayer.SetOwner( player )
	SetTeam( fakePlayer, player.GetTeam() )
	fakePlayer.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	entity mover = CreateScriptMover()
	mover.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	mover.SetModel( $"models/dev/empty_model.mdl" )
	mover.SetParent( player, "ORIGIN" )
	mover.SetOrigin( < -35, 50, 0 > ) // redirect fake player
	SetForceDrawWhileParented( mover, true )
	fakePlayer.SetParent( mover, "REF" )
	file.bleedoutFakePlayers[ player ] = fakePlayer
	fakePlayer.Anim_Play( "pt_wounded_drag_zinger_A_idle" )
}

void function Bleedout_SetProtectionDuration( float duration )
{
	file.protectionDuration = duration
}

void function Bleedout_SetIncapShieldHealth( int health )
{
	file.incapShieldMaxHealth = health
}

void function Bleedout_HealthRegenThink( entity player )
{
    player.EndSignal( "OnDestroy" )
	player.Signal( "BleedoutHealthRegenThink" ) // why this not getting registered most of time..
	player.Signal( "StopHealthRegenThink" ) // end normal health regen in _health_regen.gnut
	player.EndSignal( "BleedoutHealthRegenThink" )
	player.EndSignal( "StopHealthRegenThink" )

	float healthRegenStartDelay = file.bleedoutHealthRegenDelay

	while ( IsValid( player ) )
	{
		//print( "Bleedout Health Regen Think" )
		wait( HEALTH_REGEN_TICK_TIME )

		if ( !IsAlive( player ) )
			continue

		if ( !IsPilot( player ) )
			continue

		if ( shGlobal.proto_pilotHealthRegenDisabled )
			continue

		float healthRegenRate = file.bleedoutHealthRegenRate	// health regen per tick

		if ( player.GetHealth() == player.GetMaxHealth() )
			continue

		// No regen during phase shift
		if ( player.IsPhaseShifted() )
			continue

		// no regen during bleeding out
		if( file.isBleeding[ player ] )
			continue

		if ( Time() - player.p.lastDamageTime < healthRegenStartDelay )
		{
			continue
		}

		player.SetHealth( min( player.GetMaxHealth(), player.GetHealth() + healthRegenRate ) )
		if ( player.GetHealth() == player.GetMaxHealth() )
		{
			ClearRecentDamageHistory( player )
			ClearLastAttacker( player )
		}
	}
}

void function Bleedout_SetHealthRegenRate( float rate )
{
	file.bleedoutHealthRegenRate = rate
}

void function Bleedout_SetHealthRegenDelay( float delay )
{
	file.bleedoutHealthRegenDelay = delay
}