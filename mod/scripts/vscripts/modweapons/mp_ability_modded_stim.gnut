// everything about modded stim goes here
global function MpAbilityModdedStim_Init

global function OnWeaponPrimaryAttack_ability_modded_stim
global function OnProjectileCollision_ability_modded_stim

global function AddModdedStimPrimaryAttackCallback
global function AddModdedStimProjectileCollisionCallback

struct
{
    table< string, var functionref( entity, WeaponPrimaryAttackParams ) ornull > moddedPrimaryAttackCallbacks
    table< string, void functionref( entity, vector, vector, entity, int, bool ) ornull > moddedProjectileCollisionCallbacks
} file

void function MpAbilityModdedStim_Init()
{

}

void function AddModdedStimPrimaryAttackCallback( string modName, var functionref( entity weapon, WeaponPrimaryAttackParams attackParams ) ornull primaryAttackFunc )
{
    if ( !( modName in file.moddedPrimaryAttackCallbacks ) )
        file.moddedPrimaryAttackCallbacks[modName] <- null

    file.moddedPrimaryAttackCallbacks[modName] = primaryAttackFunc
}

void function AddModdedStimProjectileCollisionCallback( string modName, void functionref( entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical ) ornull projectileCollisionFunc )
{
    if ( !( modName in file.moddedProjectileCollisionCallbacks ) )
        file.moddedProjectileCollisionCallbacks[modName] <- null

    file.moddedProjectileCollisionCallbacks[modName] = projectileCollisionFunc
}

var function OnWeaponPrimaryAttack_ability_modded_stim( entity weapon, WeaponPrimaryAttackParams attackParams )
{
    array<string> mods = weapon.GetMods()
    foreach ( string mod in mods )
    {
        if ( mod in file.moddedPrimaryAttackCallbacks )
        {
            if ( file.moddedPrimaryAttackCallbacks[mod] != null )
            {
                return ( expect var functionref( entity, WeaponPrimaryAttackParams ) ( file.moddedPrimaryAttackCallbacks[mod] ) )( weapon, attackParams )
            }
        }
    }
}

void function OnProjectileCollision_ability_modded_stim( entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical )
{
    array<string> mods = projectile.ProjectileGetMods()
    foreach ( string mod in mods )
    {
        if ( mod in file.moddedProjectileCollisionCallbacks )
        {
            if ( file.moddedProjectileCollisionCallbacks[mod] != null )
            {
                return ( expect void functionref( entity, vector, vector, entity, int, bool ) ( file.moddedProjectileCollisionCallbacks[mod] ) )( projectile, pos, normal, hitEnt, hitbox, isCritical )
            }
        }
    }
}