global function MpWeaponSmokeLauncher_Init

global function OnWeaponPrimaryAttack_weapon_smoke_launcher
global function OnProjectileCollision_weapon_smoke_launcher
global function OnProjectileIgnite_weapon_smoke_launcher

#if SERVER
global function OnWeaponNpcPrimaryAttack_weapon_smoke_launcher

// smoke grenade settings
const int SMOKE_GRENADE_COUNT_DEFAULT = 3 // you can change smoke grenade count through the keyvalue "projectiles_per_shot"
const float SMOKE_GRENADE_VERTICAL_SPEED = 250
const float SMOKE_GRENADE_HORIZONAL_SPEED = 400

const float SMOKE_DEPLOY_DELAY = 0.7
const float SMOKE_TIME = 15
const float SMOKE_TIME_UNLIMITED_AMMO = 1

const float SMOKE_RADIUS = 150
const float SMOKE_HEIGHT = 100

struct
{
	table<entity, int> smokeLauncherGrenadeCount
} file
#endif

void function MpWeaponSmokeLauncher_Init()
{
	#if SERVER
		SmokePrecache()
	#endif
}

#if SERVER
void function SmokePrecache()
{
	PrecacheModel( $"models/weapons/grenades/smoke_grenade_projectile.mdl" )
	PrecacheParticleSystem( $"P_smokescreen_FD" )
}
#endif

var function OnWeaponPrimaryAttack_weapon_smoke_launcher( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	entity weaponOwner = weapon.GetWeaponOwner()

	if ( weaponOwner.IsPlayer() )
	{
		float zoomFrac = weaponOwner.GetZoomFrac()
		if ( zoomFrac < 1 )
			return 0
	}

	#if SERVER
		if ( weaponOwner.IsPlayer() )
		{
			vector angles = VectorToAngles( weaponOwner.GetViewVector() )
			vector up = AnglesToUp( angles )

			if ( weaponOwner.GetTitanSoulBeingRodeoed() != null ) // add some offset if player is rodeoing
				attackParams.pos = attackParams.pos + up * 20
		}
	#endif

	bool shouldPredict = weapon.ShouldPredictProjectiles()
	#if CLIENT
		if ( !shouldPredict )
			return 1
	#endif

	weapon.EmitWeaponSound_1p3p( "Weapon_MGL_Fire_1P", "Weapon_MGL_Fire_3P" )
	return FireSmokeGrenade( weapon, attackParams )
}

var function FireSmokeGrenade( entity weapon, WeaponPrimaryAttackParams attackParams, bool isNPCFiring = false )
{
	vector angularVelocity = Vector( RandomFloatRange( -1200, 1200 ), 100, 0 )

	int damageType = DF_RAGDOLL | DF_EXPLOSION

	entity nade = weapon.FireWeaponGrenade( attackParams.pos, attackParams.dir, angularVelocity, 0.0 , damageType, damageType, !isNPCFiring, true, false )

	if ( nade )
	{
		#if SERVER
			Grenade_Init( nade, weapon )
		#else
			entity weaponOwner = weapon.GetWeaponOwner()
			SetTeam( nade, weaponOwner.GetTeam() )
		#endif

		nade.SetModel( $"models/weapons/bullets/triple_threat_projectile.mdl" )

		#if SERVER
			nade.proj.savedAngles = VectorToAngles( attackParams.dir )
			file.smokeLauncherGrenadeCount[ nade ] <- weapon.GetProjectilesPerShot()
			thread DelayedStartSmokeParticle( nade )
		#endif
	}

	return 1 // fire succeeded
}

#if SERVER
var function OnWeaponNpcPrimaryAttack_weapon_smoke_launcher( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	weapon.EmitWeaponSound_1p3p( "Weapon_MGL_Fire_1P", "Weapon_MGL_Fire_3P" )
	return FireSmokeGrenade( weapon, attackParams, true )
}
#endif

void function OnProjectileCollision_weapon_smoke_launcher( entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical )
{
	entity player = projectile.GetOwner()
	if ( hitEnt == player )
		return

	if ( projectile.GrenadeHasIgnited() )
		return

	projectile.GrenadeIgnite()
	projectile.SetDoesExplode( true )
}

void function OnProjectileIgnite_weapon_smoke_launcher( entity projectile )
{
#if SERVER
	// smoke modifiers
	array<string> mods = projectile.ProjectileGetMods()
	float smokeDuration = SMOKE_TIME
	if ( mods.contains( "unlimited_balance" ) )
		smokeDuration = SMOKE_TIME_UNLIMITED_AMMO // limited smoke will last shorter
	bool isLinedUpSmoke = mods.contains( "lined_up_spread" ) // lined up spread
	//

	int grenadeCount = SMOKE_GRENADE_COUNT_DEFAULT
	if ( projectile in file.smokeLauncherGrenadeCount ) // this smoke launcher has saved grenade count
		grenadeCount = file.smokeLauncherGrenadeCount[ projectile ]

	vector origin = projectile.GetOrigin()
	array<vector> velocitygroup
	bool isOddNumber = grenadeCount % 2 != 0
	if( isOddNumber ) // spawn a center smoke if odd
	{
		vector upVector = AnglesToUp( projectile.proj.savedAngles )
		upVector.z = SMOKE_GRENADE_VERTICAL_SPEED
		velocitygroup.append( upVector )
	}
	vector baseVector = AnglesToRight( projectile.proj.savedAngles )
	vector baseAngles = < 0, VectorToAngles( baseVector ).y, 0 >
	int smokeCount = isOddNumber ? grenadeCount - 1 : grenadeCount
	if ( isLinedUpSmoke ) // lined up spead
	{
		int grenadeGroup = 1
		for( int i = 0; i < smokeCount; i += 2 )
		{
			// right grenade
			vector rightAngles = baseAngles // base angles faces right
			vector rightVel = AnglesToForward( rightAngles ) * SMOKE_GRENADE_HORIZONAL_SPEED * grenadeGroup
			rightVel.z = SMOKE_GRENADE_VERTICAL_SPEED
			velocitygroup.append( rightVel )
			// left grenade
			vector leftAngles = < 0, baseAngles.y - 180, 0 > // flip
			vector leftVel = AnglesToForward( leftAngles ) * SMOKE_GRENADE_HORIZONAL_SPEED * grenadeGroup
			leftVel.z = SMOKE_GRENADE_VERTICAL_SPEED
			velocitygroup.append( leftVel )

			grenadeGroup += 1
		}
	}
	else // rotated spead
	{
		float rotPerGrenade = 360 / float( smokeCount )
		for( int i = 0; i < smokeCount; i ++ )
		{
			vector newAngles = < 0, baseAngles.y + i * rotPerGrenade, 0 >
			vector newVector = AnglesToForward( newAngles ) * SMOKE_GRENADE_HORIZONAL_SPEED
			newVector.z = SMOKE_GRENADE_VERTICAL_SPEED
			velocitygroup.append( newVector )
		}
	}

	for( int i = 0; i < velocitygroup.len(); i++ )
	{
		vector velocety = velocitygroup[i]
		print( "current velocity: " + string( velocety ) )
		entity grenade = CreatePropAsGrenade( velocety, origin )
		thread DelayedSmokeGrenadeIgnite( grenade, SMOKE_DEPLOY_DELAY, smokeDuration )
	}

#endif
}

#if SERVER
entity function CreatePropAsGrenade( vector velocety, vector origin )
{
	entity nade = CreateEntity( "prop_physics" )
	//prop_physics does not compilable with most other models
  	nade.SetModel( $"models/dev/empty_physics.mdl" )
 	nade.SetOrigin( origin )
  	
  	DispatchSpawn( nade )
  	nade.SetVelocity( velocety )
  	StartParticleEffectOnEntity( nade, GetParticleSystemIndex( $"P_wpn_grenade_smoke_trail" ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
	thread DelayedStartSmokeParticle( nade ) // for better client visual

  	return nade
}

void function DelayedStartSmokeParticle( entity nade )
{
	WaitFrame()
	if( IsValid( nade ) )
		StartParticleEffectOnEntity( nade, GetParticleSystemIndex( $"P_wpn_grenade_smoke_trail" ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
}

void function DelayedSmokeGrenadeIgnite( entity nade, float delay, float smokeDuration )
{
	nade.EndSignal( "OnDestroy" )

	wait delay

	SmokescreenStruct smokescreen
	smokescreen.smokescreenFX = $"P_smokescreen_FD"
	smokescreen.deploySound1p = SFX_SMOKE_GRENADE_DEPLOY
	smokescreen.deploySound3p = SFX_SMOKE_GRENADE_DEPLOY
	smokescreen.isElectric = false
	smokescreen.origin = nade.GetOrigin()
	smokescreen.angles = <0,0,0>
	smokescreen.lifetime = smokeDuration
	smokescreen.fxXYRadius = SMOKE_RADIUS
	smokescreen.fxZRadius = SMOKE_HEIGHT
	smokescreen.fxOffsets = [<0.0, 0.0, 0.0>]
	Smokescreen(smokescreen)

	nade.Destroy()
}
#endif