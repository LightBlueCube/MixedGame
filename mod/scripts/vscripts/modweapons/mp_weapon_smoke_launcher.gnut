global function MpWeaponSmokeLauncher_Init

global function OnWeaponPrimaryAttack_weapon_smoke_launcher
global function OnProjectileCollision_weapon_smoke_launcher
global function OnProjectileIgnite_weapon_smoke_launcher

#if SERVER
global function OnWeaponNpcPrimaryAttack_weapon_smoke_launcher
#endif

const int SMOKE_GRENADE_COUNT = 3 // changable
const float SMOKE_GRENADE_VERTICAL_SPEED = 250
const float SMOKE_GRENADE_HORIZONAL_SPEED = 400

const float SMOKE_DEPLOY_DELAY = 0.7
const float SMOKE_TIME = 15
const float SMOKE_TIME_UNLIMITED_AMMO = 1

const float SMOKE_RADIUS = 150
const float SMOKE_HEIGHT = 100

void function MpWeaponSmokeLauncher_Init()
{
	#if SERVER
	SmokePrecache()
	RegisterSignal( "SmokeTriggerLeave" )
	#endif
}

#if SERVER
void function SmokePrecache()
{
	PrecacheModel( $"models/weapons/grenades/smoke_grenade_projectile.mdl" )
	PrecacheParticleSystem( $"P_smokescreen_FD" )
}
#endif

var function OnWeaponPrimaryAttack_weapon_smoke_launcher( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	entity weaponOwner = weapon.GetWeaponOwner()

	if ( weaponOwner.IsPlayer() )
	{
		float zoomFrac = weaponOwner.GetZoomFrac()
		if ( zoomFrac < 1 )
			return 0
	}

	#if SERVER
		if ( weaponOwner.IsPlayer() )
		{
			vector angles = VectorToAngles( weaponOwner.GetViewVector() )
			vector up = AnglesToUp( angles )

			if ( weaponOwner.GetTitanSoulBeingRodeoed() != null ) // add some offset if player is rodeoing
				attackParams.pos = attackParams.pos + up * 20
		}
	#endif

	bool shouldPredict = weapon.ShouldPredictProjectiles()
	#if CLIENT
		if ( !shouldPredict )
			return 1
	#endif

	weapon.EmitWeaponSound_1p3p( "Weapon_MGL_Fire_1P", "Weapon_MGL_Fire_3P" )
	return FireSmokeGrenade( weapon, attackParams )
}

var function FireSmokeGrenade( entity weapon, WeaponPrimaryAttackParams attackParams, bool isNPCFiring = false )
{
	vector angularVelocity = Vector( RandomFloatRange( -1200, 1200 ), 100, 0 )

	int damageType = DF_RAGDOLL | DF_EXPLOSION

	entity nade = weapon.FireWeaponGrenade( attackParams.pos, attackParams.dir, angularVelocity, 0.0 , damageType, damageType, !isNPCFiring, true, false )

	if ( nade )
	{
		#if SERVER
			Grenade_Init( nade, weapon )
		#else
			entity weaponOwner = weapon.GetWeaponOwner()
			SetTeam( nade, weaponOwner.GetTeam() )
		#endif

		nade.SetModel( $"models/weapons/bullets/triple_threat_projectile.mdl" )

		#if SERVER
			nade.proj.savedAngles = VectorToAngles( attackParams.dir )
			thread DelayedStartSmokeParticle( nade )
		#endif
	}

	return 1 // fire succeeded
}

#if SERVER
var function OnWeaponNpcPrimaryAttack_weapon_smoke_launcher( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	weapon.EmitWeaponSound_1p3p( "Weapon_MGL_Fire_1P", "Weapon_MGL_Fire_3P" )
	return FireSmokeGrenade( weapon, attackParams, true )
}
#endif

void function OnProjectileCollision_weapon_smoke_launcher( entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical )
{
	entity player = projectile.GetOwner()
	if ( hitEnt == player )
		return

	if ( projectile.GrenadeHasIgnited() )
		return

	projectile.GrenadeIgnite()
	projectile.SetDoesExplode( true )
}

void function OnProjectileIgnite_weapon_smoke_launcher( entity projectile )
{
#if SERVER
	// smoke modifiers
	array<string> mods = projectile.ProjectileGetMods()
	bool isLimitedSmoke = false
	if( mods.contains( "unlimited_balance" ) )
		isLimitedSmoke = true // limited smoke will last shorter
	//

	vector origin = projectile.GetOrigin()
	array<vector> velocitygroup
	bool isOddNumber = SMOKE_GRENADE_COUNT % 2 != 0
	if( isOddNumber ) // spawn a center smoke if odd
	{
		vector upVector = AnglesToUp( projectile.proj.savedAngles )
		upVector.z = SMOKE_GRENADE_VERTICAL_SPEED
		velocitygroup.append( upVector )
	}
	vector baseVector = AnglesToRight( projectile.proj.savedAngles )
	vector baseAngles = < 0, VectorToAngles( baseVector ).y, 0 >
	int smokeCount = isOddNumber ? SMOKE_GRENADE_COUNT - 1 : SMOKE_GRENADE_COUNT
	float rotPerGrenade = 360 / float( smokeCount )
	for( int i = 0; i < smokeCount; i++ )
	{
		vector newAngles = < 0, baseAngles.y + i * rotPerGrenade, 0 >
		vector newVector = AnglesToForward( newAngles ) * SMOKE_GRENADE_HORIZONAL_SPEED
		newVector.z = SMOKE_GRENADE_VERTICAL_SPEED
		velocitygroup.append( newVector )
	}

	for( int i = 0; i < velocitygroup.len(); i++ )
	{
		vector velocety = velocitygroup[i]
		entity grenade = CreatePropAsGrenade( velocety, origin )
		thread DelayedSmokeGrenadeIgnite( grenade, isLimitedSmoke )
	}

#endif
}

#if SERVER
entity function CreatePropAsGrenade( vector velocety, vector origin )
{
	entity nade = CreateEntity( "prop_physics" )
	//prop_physics does not compilable with most other models
  	nade.SetModel( $"models/dev/empty_physics.mdl" )
 	nade.SetOrigin( origin )
  	
  	DispatchSpawn( nade )
  	nade.SetVelocity( velocety )
  	StartParticleEffectOnEntity( nade, GetParticleSystemIndex( $"P_wpn_grenade_smoke_trail" ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
	thread DelayedStartSmokeParticle( nade ) // for better client visual

  	return nade
}

void function DelayedStartSmokeParticle( entity nade )
{
	WaitFrame()
	if( IsValid( nade ) )
		StartParticleEffectOnEntity( nade, GetParticleSystemIndex( $"P_wpn_grenade_smoke_trail" ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
}

void function DelayedSmokeGrenadeIgnite( entity nade, bool shouldReduce = false )
{
	nade.EndSignal( "OnDestroy" )

	wait SMOKE_DEPLOY_DELAY

	SmokescreenStruct smokescreen
	smokescreen.smokescreenFX = $"P_smokescreen_FD"
	smokescreen.deploySound1p = SFX_SMOKE_GRENADE_DEPLOY
	smokescreen.deploySound3p = SFX_SMOKE_GRENADE_DEPLOY
	smokescreen.isElectric = false
	smokescreen.origin = nade.GetOrigin()
	smokescreen.angles = <0,0,0>
	smokescreen.lifetime = shouldReduce ? SMOKE_TIME_UNLIMITED_AMMO : SMOKE_TIME
	smokescreen.fxXYRadius = SMOKE_RADIUS
	smokescreen.fxZRadius = SMOKE_HEIGHT
	smokescreen.fxOffsets = [<0.0, 0.0, 0.0>]
	Smokescreen(smokescreen)

	nade.Destroy()
}
#endif