untyped // for weapon.s to work
global function MpTitanAbilityVortexBlocker_Init

global function OnWeaponOwnerChanged_titanability_vortex_blocker
global function OnWeaponChargeBegin_titanability_vortex_blocker

// consts
const float VORTEX_BLOCKER_ENERGY_REGEN_RATE        = 125 // 8s for normal titans( they have 1000 max energy )
const float VORTEX_BLOCKER_ENERGY_REGEN_DELAY       = 0.5 // 
const float VORTEX_BLOCKER_ACTIVATION_COST_FRAC     = 0.05 // each activation will cost some energy

#if SERVER
struct PlayerSharedEnergy
{
    float regenRate
    float regenDelay
}

struct
{
    table<entity, entity> blockerLastOwner
    table<entity, PlayerSharedEnergy> blockerOwnerSharedEnergyTable
} file
#endif

void function MpTitanAbilityVortexBlocker_Init()
{
#if SERVER
    AddCallback_OnPilotBecomesTitan( OnClassChangeBecomeTitan )
    AddCallback_OnTitanBecomesPilot( OnClassChangeBecomePilot )
#endif
}

void function OnWeaponOwnerChanged_titanability_vortex_blocker( entity weapon, WeaponOwnerChangedParams changeParams )
{
    // should match OnWeaponOwnerChanged_titanweapon_vortex_shield() for client prediction!
    if ( !( "initialized" in weapon.s ) )
	{
		weapon.s.fxChargingFPControlPoint <- $"wpn_vortex_chargingCP_titan_FP"
		weapon.s.fxChargingFPControlPointReplay <- $"wpn_vortex_chargingCP_titan_FP_replay"
		weapon.s.fxChargingControlPoint <- $"wpn_vortex_chargingCP_titan"
		weapon.s.fxBulletHit <- $"wpn_vortex_shield_impact_titan"

		weapon.s.fxChargingFPControlPointBurn <- $"wpn_vortex_chargingCP_mod_FP"
		weapon.s.fxChargingFPControlPointReplayBurn <- $"wpn_vortex_chargingCP_mod_FP_replay"
		weapon.s.fxChargingControlPointBurn <- $"wpn_vortex_chargingCP_mod"
		weapon.s.fxBulletHitBurn <- $"wpn_vortex_shield_impact_mod"

		weapon.s.fxElectricalExplosion <- $"P_impact_exp_emp_med_air"

		weapon.s.lastFireTime <- 0
		weapon.s.hadChargeWhenFired <- false


		#if CLIENT
			weapon.s.lastUseTime <- 0
		#endif

		weapon.s.initialized <- true
	}
    // initialize end

#if SERVER
    if ( !( weapon in file.blockerLastOwner ) )
        file.blockerLastOwner[ weapon ] <- null // init
    // vortex blocker
    entity lastOwner = file.blockerLastOwner[ weapon ]
    //print( "lastOwner is: " + string( lastOwner ) )
    entity oldOwner = changeParams.oldOwner
    //print( "oldOwner is: " + string( oldOwner ) )
    entity newOwner = changeParams.newOwner
    //print( "newOwner is: " + string( newOwner ) )
    if ( IsValid( oldOwner ) )
    {
        if ( oldOwner == lastOwner ) // was the weapon's last owner!
        {
            if ( oldOwner in file.blockerOwnerSharedEnergyTable ) // in sharedEnergyTable!
            {
                //print( "try to restore saved energy settings" )
                // reset the regen
                float regenRate = file.blockerOwnerSharedEnergyTable[ oldOwner ].regenRate
                //print( "regenRate is: " + string( regenRate ) )
                float regenDelay = file.blockerOwnerSharedEnergyTable[ oldOwner ].regenDelay
                //print( "regenDelay is: " + string( regenDelay ) )
                oldOwner.SetSharedEnergyRegenRate( regenRate )
                oldOwner.SetSharedEnergyRegenDelay( regenDelay )
            }
        }
    }
    if ( IsValid( newOwner ) ) // don't change sharedEnergyTotal, since client can't predict it
    {
        if ( !( newOwner in file.blockerOwnerSharedEnergyTable ) )
        {
            PlayerSharedEnergy emptyStruct
            file.blockerOwnerSharedEnergyTable[ newOwner ] <- emptyStruct
        }
        file.blockerLastOwner[ weapon ] = newOwner // update ownership

        // save current energy stats
        //print( "try to store energy settings" )
        float regenRate = newOwner.GetSharedEnergyRegenRate()
        //print( "regenRate is: " + string( regenRate ) )
        float regenDelay = newOwner.GetSharedEnergyRegenDelay()
        //print( "regenDelay is: " + string( regenDelay ) )
        file.blockerOwnerSharedEnergyTable[ newOwner ].regenRate = regenRate
        file.blockerOwnerSharedEnergyTable[ newOwner ].regenDelay = regenDelay

        //print( "try to update energy" )
        //int totalEnergy = newOwner.GetSharedEnergyTotal()
        //int currentEnergy = newOwner.GetSharedEnergyCount()
        //float energyLeft = float ( currentEnergy ) / float ( totalEnergy ) // get current energy left
        // get new regen rate and regen delay
        float newRegenRate = VORTEX_BLOCKER_ENERGY_REGEN_RATE
        //print( "newRegenRate is: " + string( newRegenRate ) )
        float newRegenDelay = VORTEX_BLOCKER_ENERGY_REGEN_DELAY
        //print( "newRegenDelay is: " + string( newRegenDelay ) )

        // update to owner
        newOwner.SetSharedEnergyRegenRate( newRegenRate )
        newOwner.SetSharedEnergyRegenDelay( newRegenDelay )
    }
#endif
}

// this one shouldn't overwrite default vortex
void function OnWeaponChargeBegin_titanability_vortex_blocker( entity weapon )
{
#if SERVER
    // this weapon uses serverSide only
    ApplyActivationCost( weapon, VORTEX_BLOCKER_ACTIVATION_COST_FRAC )
#endif
}

// this weapon uses serverSide only
#if SERVER
void function ApplyActivationCost( entity weapon, float frac )
{
    entity owner = weapon.GetWeaponOwner()
    if ( !IsValid( owner ) )
        return
    
    int totalEnergy = owner.GetSharedEnergyTotal()
    int currentEnergy = owner.GetSharedEnergyCount()
    int energyToReduce = int ( totalEnergy * frac )

    owner.TakeSharedEnergy( min ( energyToReduce, currentEnergy ) )
}
#endif

#if SERVER
// this will be running after setPlayerSettings(), it will apply to titan
void function OnClassChangeBecomeTitan( entity player, entity titan )
{
    //print( "HasVortexBlocker( player ): " + string( HasVortexBlocker( player ) ) )
    //print( "HasVortexBlocker( titan ): " + string( HasVortexBlocker( titan ) ) )
    if ( !HasVortexBlocker( player ) )
        return

    entity weapon = GetVortexBlocker( player )
    if ( !IsValid( weapon ) )
        return
    if ( !( weapon in file.blockerLastOwner ) )
        return

    // do this check again!
    entity lastOwner = file.blockerLastOwner[ weapon ]
    //print( "lastOwner is: " + string( lastOwner ) )
    //print( "embarkedPlayer is: " + string( player ) )
    if ( lastOwner == player )
    {
        // update again, for player has been reset playerSettings
        float newRegenRate = VORTEX_BLOCKER_ENERGY_REGEN_RATE
        //print( "newRegenRate is: " + string( newRegenRate ) )
        float newRegenDelay = VORTEX_BLOCKER_ENERGY_REGEN_DELAY
        //print( "newRegenDelay is: " + string( newRegenDelay ) )

        player.SetSharedEnergyRegenRate( newRegenRate )
        player.SetSharedEnergyRegenDelay( newRegenDelay )
    }
}

void function OnClassChangeBecomePilot( entity player, entity titan )
{

}

bool function HasVortexBlocker( entity ent )
{
    entity shieldWeapon = GetVortexBlocker( ent )
    if ( !IsValid( shieldWeapon ) )
        return false
    
    return true
}

entity function GetVortexBlocker( entity ent )
{
    entity shieldWeapon
    foreach ( entity weapon in ent.GetOffhandWeapons() )
    {
        if ( weapon.HasMod( "vortex_blocker" ) )
            shieldWeapon = weapon
    }
    
    return shieldWeapon
}
#endif