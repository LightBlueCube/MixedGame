global function MpWeaponNessiePistol_Init

global function OnWeaponPrimaryAttack_weapon_nessie_pistol

global function OnProjectileCollision_weapon_nessie_pistol
global function OnProjectileIgnite_weapon_nessie_pistol

#if SERVER
global function OnWeaponNPCPrimaryAttack_weapon_nessie_pistol
#endif

const float NESSIE_DRONE_LIFETIME = 12
const asset NESSIE_MODEL = $"models/domestic/nessy_doll.mdl"
const asset NESSIE_DRONE_FX = $"P_xo_battery"

void function MpWeaponNessiePistol_Init()
{
	#if SERVER
		NessiePrecache()
	#endif
}

#if SERVER
void function NessiePrecache()
{
	PrecacheModel( $"models/domestic/nessy_doll.mdl" )
	PrecacheParticleSystem( $"P_xo_battery" )
}
#endif

var function OnWeaponPrimaryAttack_weapon_nessie_pistol( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	return FireNessieGrenade( weapon, attackParams, false )
}

var function FireNessieGrenade( entity weapon, WeaponPrimaryAttackParams attackParams, bool isNPCFiring = false )
{
	vector angularVelocity = Vector( RandomFloatRange( -1200, 1200 ), 100, 0 )

	int damageType = DF_RAGDOLL | DF_EXPLOSION

	entity nade = weapon.FireWeaponGrenade( attackParams.pos, attackParams.dir, angularVelocity, 0.0 , damageType, damageType, !isNPCFiring, true, false )

	if ( nade )
	{
		#if SERVER
			Grenade_Init( nade, weapon )
		#else
			entity weaponOwner = weapon.GetWeaponOwner()
			SetTeam( nade, weaponOwner.GetTeam() )
		#endif

		nade.SetModel( NESSIE_MODEL )
		return 1
	}
}

void function OnProjectileCollision_weapon_nessie_pistol( entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical )
{
	entity player = projectile.GetOwner()
	if ( hitEnt == player )
		return

	if ( projectile.GrenadeHasIgnited() )
		return

	projectile.GrenadeIgnite() // so the grenade can bounce without triggering this multiple times if we want!
	projectile.SetDoesExplode( true )
}

void function OnProjectileIgnite_weapon_nessie_pistol( entity projectile )
{
	#if SERVER
		array<string> mods = projectile.ProjectileGetMods()

		if ( mods.contains( "nessie_drone_spawn" ) )
			GrenadesToDrones( projectile )
	#endif
}

#if SERVER
// utility
entity function CreateNessieForEnt( entity targetEnt, string attachment )
{
	entity nessie = CreateEntity( "prop_dynamic" )
	nessie.SetModel( NESSIE_MODEL )
	nessie.SetParent( targetEnt, attachment )
	nessie.SetAngles( < 0, -90, 0 > )

	nessie.kv.solid = SOLID_HITBOXES
	nessie.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS

	DispatchSpawn( nessie )

	nessie.SetMaxHealth( targetEnt.GetMaxHealth() )
	nessie.SetHealth( nessie.GetMaxHealth() )

	nessie.SetOwner( targetEnt ) // hopefully this can avoid them block it's owner shoot

	AddEntityCallback_OnDamaged( nessie, OnNessieDamaged )
	targetEnt.SetInvulnerable() // we clean it when nessie takes damage!
	return nessie
}

void function OnNessieDamaged( entity nessie, var damageInfo )
{
	// re-direct damage to it's owner
	entity victim = nessie.GetOwner()

	if ( IsValid( victim ) )
	{
		victim.ClearInvulnerable() // clear once, they'll take damage

		victim.TakeDamage(
			DamageInfo_GetDamage( damageInfo ),
			DamageInfo_GetAttacker( damageInfo ), 
			DamageInfo_GetInflictor( damageInfo ), 
			{ // damage table
				weapon = DamageInfo_GetWeapon( damageInfo ),
				origin = DamageInfo_GetDamagePosition( damageInfo ), 
				force = DamageInfo_GetDamageForce( damageInfo ), 
				scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
				damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
			}
		)

		victim.SetInvulnerable()

		// player hitmarker
		entity attacker = DamageInfo_GetAttacker( damageInfo )
		if ( IsValid( attacker ) && attacker.IsPlayer() )
		{
			attacker.NotifyDidDamage( 
				victim, 
				DamageInfo_GetHitBox( damageInfo ), 
				DamageInfo_GetDamagePosition( damageInfo ), 
				DamageInfo_GetCustomDamageType( damageInfo ), 
				DamageInfo_GetDamage( damageInfo ), 
				DamageInfo_GetDamageFlags( damageInfo ), 
				DamageInfo_GetHitGroup( damageInfo ), 
				DamageInfo_GetWeapon( damageInfo ), 
				DamageInfo_GetDistFromAttackOrigin( damageInfo ) 
			)
		}
	}

	DamageInfo_SetDamage( damageInfo, 0 )
}

//

// nessie drone
void function GrenadesToDrones( entity nade )
{
	entity owner = nade.GetThrower()
	vector pos = nade.GetOrigin() + Vector(0,0,10)
	vector angs = nade.GetAngles()
	int team = nade.GetTeam()

	array<string> validDroneTypes = 
    [ 
        "npc_drone_beam", 
        "npc_drone_rocket", 
        "npc_drone_plasma" 
    ]
	string dronename = validDroneTypes[ RandomInt( validDroneTypes.len() ) ]

	entity drone = CreateNPC( "npc_drone", team , pos, angs )
	SetSpawnOption_AISettings( drone, dronename )
	drone.kv.modelscale = 0.01
	//drone.kv.modelscale = 0.5
	//drone.Hide() // this one can't show a title!
	DispatchSpawn( drone )
	drone.SetTitle( "小尼斯水怪" )
	drone.SetMaxHealth( 50 )
	drone.SetHealth( drone.GetMaxHealth() )
	//drone.SetOwner( owner )
	drone.SetBossPlayer( owner )
	//NPCFollowsPlayer( drone, owner ) // weird one

	// attach a nessie
	entity nessie = CreateNessieForEnt( drone, "CHESTFOCUS" )
	
	thread DisableNessieDroneSound( drone )
	thread NessieDroneLifetime( drone, nessie, NESSIE_DRONE_LIFETIME )
	//thread AfterTimeDissolveNessieDrone( drone, nessie, fx, NESSIE_DRONE_LIFETIME )
}

void function DisableNessieDroneSound( entity drone ) // annoying sound!
{
	drone.EndSignal( "OnDestroy" )
	
	while( true )
	{
		StopSoundOnEntity( drone, "Drone_Mvmt_Hover_Hero" )
		StopSoundOnEntity( drone, "Drone_Mvmt_Hover" )
		StopSoundOnEntity( drone, "Drone_Mvmt_Turn" )
		
		WaitFrame()
	}
}

void function NessieDroneLifetime( entity drone, entity nessie, float delay )
{
	drone.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function(): ( drone, nessie )
		{
			if( IsValid( nessie ) )
			{
				nessie.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
			}
			if( IsValid( drone ) )
			{
				PlayFX( $"P_plasma_exp_SM", drone.GetOrigin(), drone.GetAngles() )
				EmitSoundAtPosition( TEAM_UNASSIGNED, drone.GetOrigin(), "explo_plasma_small" )
				drone.Destroy()
			}
		}
	)
	
	wait delay
}

void function AfterTimeDissolveNessieDrone( entity drone, entity nessie, entity fx, float delay )
{
	wait delay
	if( IsValid(drone) )
		drone.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
	if( IsValid(nessie) )
		nessie.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
	if( IsValid(fx) )
		EffectStop( fx )

}


var function OnWeaponNPCPrimaryAttack_weapon_nessie_pistol( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	return FireNessieGrenade( weapon, attackParams, true )
}
#endif